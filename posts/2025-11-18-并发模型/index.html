<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>一些并发的模型 | sheep44044的小站</title>
<meta name="keywords" content="">
<meta name="description" content="1. 生产者-消费者模型
这是最基础、最常用、也是最实用的模型。

有两个或多个生产者线程，它们生产数据（或任务）并放入一个共享的缓冲区。
有一个或多个消费者线程，它们从缓冲区中取出数据（或任务）并进行处理。
生产者和消费者之间通过这个缓冲区进行解耦。

核心挑战：

缓冲区为空：消费者不能从空缓冲区取数据。
缓冲区已满：生产者不能向已满的缓冲区放数据。
竞态条件：对缓冲区的访问必须是互斥的，防止多个线程同时修改导致数据不一致。

package main

import (
    &#34;fmt&#34;
    &#34;time&#34;
)

type Task struct {
    Runnable func(workerId int)
}

func main() {
    // 一个负责任务分发的管道
    ch := make(chan Task, 10)

    // 启动几个 worker 负责处理任务
    for id := range 10 {
        go func(workerId int) {
            for t := range ch {
                t.Runnable(workerId)
            }
        }(id)
    }

    // 任务分发
    for i := range 20 {
	    j := i
        t1 := Task{
            Runnable: func(workerId int) {
                fmt.Printf(&#34;workerId%v：task%v做一件事情\n&#34;, workerId, j)
            },
        }
        ch &lt;- t1
    }
    time.Sleep(1 * time.Second)
    close(ch)
}
现实应用：">
<meta name="author" content="Sheep44044">
<link rel="canonical" href="https://sheep44044.github.io/posts/2025-11-18-%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.2211ca3164be7830024f6aad2b3a2e520843a64f8f048445c3401c1249aa051d.css" integrity="sha256-IhHKMWS&#43;eDACT2qtKzouUghDpk&#43;PBIRFw0AcEkmqBR0=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://sheep44044.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://sheep44044.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://sheep44044.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://sheep44044.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://sheep44044.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://sheep44044.github.io/posts/2025-11-18-%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="https://sheep44044.github.io/posts/2025-11-18-%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B/">
  <meta property="og:site_name" content="sheep44044的小站">
  <meta property="og:title" content="一些并发的模型">
  <meta property="og:description" content="1. 生产者-消费者模型 这是最基础、最常用、也是最实用的模型。
有两个或多个生产者线程，它们生产数据（或任务）并放入一个共享的缓冲区。 有一个或多个消费者线程，它们从缓冲区中取出数据（或任务）并进行处理。 生产者和消费者之间通过这个缓冲区进行解耦。 核心挑战：
缓冲区为空：消费者不能从空缓冲区取数据。 缓冲区已满：生产者不能向已满的缓冲区放数据。 竞态条件：对缓冲区的访问必须是互斥的，防止多个线程同时修改导致数据不一致。 package main import ( &#34;fmt&#34; &#34;time&#34; ) type Task struct { Runnable func(workerId int) } func main() { // 一个负责任务分发的管道 ch := make(chan Task, 10) // 启动几个 worker 负责处理任务 for id := range 10 { go func(workerId int) { for t := range ch { t.Runnable(workerId) } }(id) } // 任务分发 for i := range 20 { j := i t1 := Task{ Runnable: func(workerId int) { fmt.Printf(&#34;workerId%v：task%v做一件事情\n&#34;, workerId, j) }, } ch &lt;- t1 } time.Sleep(1 * time.Second) close(ch) } 现实应用：">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-11-18T20:31:14+08:00">
    <meta property="article:modified_time" content="2025-11-18T20:31:14+08:00">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="一些并发的模型">
<meta name="twitter:description" content="1. 生产者-消费者模型
这是最基础、最常用、也是最实用的模型。

有两个或多个生产者线程，它们生产数据（或任务）并放入一个共享的缓冲区。
有一个或多个消费者线程，它们从缓冲区中取出数据（或任务）并进行处理。
生产者和消费者之间通过这个缓冲区进行解耦。

核心挑战：

缓冲区为空：消费者不能从空缓冲区取数据。
缓冲区已满：生产者不能向已满的缓冲区放数据。
竞态条件：对缓冲区的访问必须是互斥的，防止多个线程同时修改导致数据不一致。

package main

import (
    &#34;fmt&#34;
    &#34;time&#34;
)

type Task struct {
    Runnable func(workerId int)
}

func main() {
    // 一个负责任务分发的管道
    ch := make(chan Task, 10)

    // 启动几个 worker 负责处理任务
    for id := range 10 {
        go func(workerId int) {
            for t := range ch {
                t.Runnable(workerId)
            }
        }(id)
    }

    // 任务分发
    for i := range 20 {
	    j := i
        t1 := Task{
            Runnable: func(workerId int) {
                fmt.Printf(&#34;workerId%v：task%v做一件事情\n&#34;, workerId, j)
            },
        }
        ch &lt;- t1
    }
    time.Sleep(1 * time.Second)
    close(ch)
}
现实应用：">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://sheep44044.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "一些并发的模型",
      "item": "https://sheep44044.github.io/posts/2025-11-18-%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "一些并发的模型",
  "name": "一些并发的模型",
  "description": "1. 生产者-消费者模型 这是最基础、最常用、也是最实用的模型。\n有两个或多个生产者线程，它们生产数据（或任务）并放入一个共享的缓冲区。 有一个或多个消费者线程，它们从缓冲区中取出数据（或任务）并进行处理。 生产者和消费者之间通过这个缓冲区进行解耦。 核心挑战：\n缓冲区为空：消费者不能从空缓冲区取数据。 缓冲区已满：生产者不能向已满的缓冲区放数据。 竞态条件：对缓冲区的访问必须是互斥的，防止多个线程同时修改导致数据不一致。 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) type Task struct { Runnable func(workerId int) } func main() { // 一个负责任务分发的管道 ch := make(chan Task, 10) // 启动几个 worker 负责处理任务 for id := range 10 { go func(workerId int) { for t := range ch { t.Runnable(workerId) } }(id) } // 任务分发 for i := range 20 { j := i t1 := Task{ Runnable: func(workerId int) { fmt.Printf(\u0026#34;workerId%v：task%v做一件事情\\n\u0026#34;, workerId, j) }, } ch \u0026lt;- t1 } time.Sleep(1 * time.Second) close(ch) } 现实应用：\n",
  "keywords": [
    
  ],
  "articleBody": "1. 生产者-消费者模型 这是最基础、最常用、也是最实用的模型。\n有两个或多个生产者线程，它们生产数据（或任务）并放入一个共享的缓冲区。 有一个或多个消费者线程，它们从缓冲区中取出数据（或任务）并进行处理。 生产者和消费者之间通过这个缓冲区进行解耦。 核心挑战：\n缓冲区为空：消费者不能从空缓冲区取数据。 缓冲区已满：生产者不能向已满的缓冲区放数据。 竞态条件：对缓冲区的访问必须是互斥的，防止多个线程同时修改导致数据不一致。 package main import ( \"fmt\" \"time\" ) type Task struct { Runnable func(workerId int) } func main() { // 一个负责任务分发的管道 ch := make(chan Task, 10) // 启动几个 worker 负责处理任务 for id := range 10 { go func(workerId int) { for t := range ch { t.Runnable(workerId) } }(id) } // 任务分发 for i := range 20 { j := i t1 := Task{ Runnable: func(workerId int) { fmt.Printf(\"workerId%v：task%v做一件事情\\n\", workerId, j) }, } ch \u003c- t1 } time.Sleep(1 * time.Second) close(ch) } 现实应用：\n消息队列（如Kafka, RabbitMQ）。 线程池任务调度。 Golang中的Channel，Java中的 BlockingQueue 其底层思想就是生产者-消费者模型。 2. 读者-写者问题 核心思想：在读多写少的问题中，对读写锁的使用，写锁类似于互斥锁，读锁类似于共享锁（能开多个）。\n读者只读取共享数据，不修改，写者会修改共享数据。允许多个读者同时读，但写者必须独占访问（即写时不能有读者或其他写者）。\n核心挑战：\n在保证数据一致性的前提下，最大限度地提高并发性（特别是对读者）。 可能导致写者饥饿：如果读者源源不断，写者可能永远无法获得访问权。 package main import ( \"fmt\" \"sync\" \"time\" ) func main() { var ( data int rwMutex sync.RWMutex // 读写锁 wg sync.WaitGroup ) // 写者 wg.Add(1) go func() { defer wg.Done() for i := 0; i \u003c 5; i++ { rwMutex.Lock() // 写锁 data = i fmt.Printf(\"写入: %d\\n\", i) time.Sleep(time.Millisecond * 200) rwMutex.Unlock() time.Sleep(time.Millisecond * 100) } }() // 读者（多个） for i := 0; i \u003c 3; i++ { wg.Add(1) go func(id int) { defer wg.Done() for j := 0; j \u003c 5; j++ { rwMutex.RLock() // 读锁 fmt.Printf(\"读者%d 读取: %d\\n\", id, data) time.Sleep(time.Millisecond * 50) rwMutex.RUnlock() time.Sleep(time.Millisecond * 100) } }(i) } wg.Wait() } 现实应用：\n数据库的并发控制。 文件系统、缓存的访问。 3. 哲学家就餐问题 核心思想：避免多个进程（或线程）竞争有限资源时的死锁问题，通过特定的策略(破坏循环)或限制并发度（筷子数量）等方法，解决死锁问题。\n五个哲学家围坐在一张圆桌旁，他们的一生只在做两件事：思考和吃饭。 桌上有五根筷子（不是五双），每两个哲学家之间有一根。 哲学家吃饭时需要同时拿起他左边和右边的筷子。 如果筷子在别人手里，他就必须等待。 核心挑战：\n死锁：如果所有哲学家同时感到饥饿，并同时拿起自己左边的筷子，那么所有人都会永远等待右边的筷子被释放，导致系统僵住。\npackage main import ( \"fmt\" \"sync\" \"time\" ) func main() { // 5根筷子（互斥锁） chopsticks := make([]sync.Mutex, 5) var wg sync.WaitGroup // 哲学家函数 philosopher := func(id int) { defer wg.Done() left := id right := (id + 1) % 5 // 避免死锁：编号为偶数的哲学家先拿左边，奇数先拿右边 for i := 0; i \u003c 3; i++ { // 吃3次 if id%2 == 0 { chopsticks[left].Lock() chopsticks[right].Lock() } else { chopsticks[right].Lock() chopsticks[left].Lock() } // 拿到两根筷子，开始吃饭 fmt.Printf(\"哲学家%d 正在吃饭...\\n\", id) time.Sleep(time.Millisecond * 100) // 放下筷子 chopsticks[left].Unlock() chopsticks[right].Unlock() // 思考 fmt.Printf(\"哲学家%d 正在思考...\\n\", id) time.Sleep(time.Millisecond * 100) } } // 启动5个哲学家 for i := 0; i \u003c 5; i++ { wg.Add(1) go philosopher(i) } wg.Wait() } 现实应用：\n任何需要获取多个互斥资源才能工作的场景，比如进程需要同时锁定多个数据库记录进行更新。\n4. 理发师问题 核心思想：模拟有容量限制的服务系统，通过空结构体(似乎叫信号量)来实现请求者与服务者的同步，并实现超容量时的拒绝和服务者的空闲/工作状态转换。\n一个理发店有一个理发师（服务线程）、一把理发椅（临界资源）和N把供顾客等待的椅子（等待队列）。 如果没有顾客，理发师就在理发椅上睡觉。 顾客到来时，如果理发师在睡觉，就叫醒他理发。 如果理发师在忙，顾客就坐在等待椅上等待。 如果等待椅也坐满了，顾客就会离开。 核心挑战：\n协调理发师（服务者）和顾客（请求者）的睡眠与唤醒。 管理有限的等待队列。 package main import ( \"fmt\" \"math/rand\" \"sync\" \"time\" ) func main() { // 理发店参数 const ( waitingChairs = 3 // 等待椅数量 totalCustomers = 10 // 总顾客数 ) var ( waitingRoom = make(chan struct{}, waitingChairs) // 等待室（缓冲channel） wg sync.WaitGroup barberReady = make(chan struct{}, 1) // 理发师就绪信号 ) // 理发师 wg.Add(1) go func() { defer wg.Done() for { select { case \u003c-waitingRoom: // 有顾客，开始理发 barberReady \u003c- struct{}{} // 理发师准备就绪 fmt.Println(\"理发师正在理发...\") time.Sleep(time.Millisecond * 200) // 理发时间 fmt.Println(\"理发完成！\") default: // 没有顾客，睡觉 fmt.Println(\"理发师在睡觉...\") time.Sleep(time.Millisecond * 500) } } }() // 顾客 for i := 0; i \u003c totalCustomers; i++ { wg.Add(1) go func(id int) { defer wg.Done() time.Sleep(time.Millisecond * time.Duration(rand.Intn(300))) select { case waitingRoom \u003c- struct{}{}: // 成功进入等待室 fmt.Printf(\"顾客%d 在等待理发\\n\", id) \u003c-barberReady // 等待理发师就绪 fmt.Printf(\"顾客%d 正在理发\\n\", id) default: // 等待室满了，离开 fmt.Printf(\"顾客%d 看到等待室满了，离开了\\n\", id) } }(i) } // 等待所有顾客完成 time.Sleep(time.Second * 3) fmt.Println(\"营业结束\") } 现实应用：\n线程池或服务器模型。例如，一个Web服务器有固定数量的工作线程（理发师）和一个最大连接队列（等待椅）。当新请求到达时，如果有空闲线程则立即处理，否则进入队列等待，如果队列也满了，则返回“服务器繁忙”错误。\n",
  "wordCount" : "478",
  "inLanguage": "en",
  "datePublished": "2025-11-18T20:31:14+08:00",
  "dateModified": "2025-11-18T20:31:14+08:00",
  "author":{
    "@type": "Person",
    "name": "Sheep44044"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://sheep44044.github.io/posts/2025-11-18-%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "sheep44044的小站",
    "logo": {
      "@type": "ImageObject",
      "url": "https://sheep44044.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://sheep44044.github.io/" accesskey="h" title="sheep44044的小站 (Alt + H)">sheep44044的小站</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://sheep44044.github.io/" title="主页">
                    <span>主页</span>
                </a>
            </li>
            <li>
                <a href="https://sheep44044.github.io/about/" title="个人">
                    <span>个人</span>
                </a>
            </li>
            <li>
                <a href="https://sheep44044.github.io/posts/" title="文章">
                    <span>文章</span>
                </a>
            </li>
            <li>
                <a href="https://sheep44044.github.io/leetcode/" title="刷题">
                    <span>刷题</span>
                </a>
            </li>
            <li>
                <a href="https://sheep44044.github.io/daily/" title="日常">
                    <span>日常</span>
                </a>
            </li>
            <li>
                <a href="https://sheep44044.github.io/weekly/" title="周报">
                    <span>周报</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      一些并发的模型
    </h1>
    <div class="post-meta"><span title='2025-11-18 20:31:14 +0800 CST'>November 18, 2025</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Sheep44044

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#1-%e7%94%9f%e4%ba%a7%e8%80%85-%e6%b6%88%e8%b4%b9%e8%80%85%e6%a8%a1%e5%9e%8b" aria-label="1. 生产者-消费者模型">1. 生产者-消费者模型</a></li>
                <li>
                    <a href="#2-%e8%af%bb%e8%80%85-%e5%86%99%e8%80%85%e9%97%ae%e9%a2%98" aria-label="2. 读者-写者问题">2. 读者-写者问题</a></li>
                <li>
                    <a href="#3-%e5%93%b2%e5%ad%a6%e5%ae%b6%e5%b0%b1%e9%a4%90%e9%97%ae%e9%a2%98" aria-label="3. 哲学家就餐问题">3. 哲学家就餐问题</a></li>
                <li>
                    <a href="#4-%e7%90%86%e5%8f%91%e5%b8%88%e9%97%ae%e9%a2%98" aria-label="4. 理发师问题">4. 理发师问题</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="1-生产者-消费者模型">1. 生产者-消费者模型<a hidden class="anchor" aria-hidden="true" href="#1-生产者-消费者模型">#</a></h2>
<p>这是最基础、最常用、也是最实用的模型。</p>
<ul>
<li>有两个或多个<strong>生产者</strong>线程，它们生产数据（或任务）并放入一个共享的<strong>缓冲区</strong>。</li>
<li>有一个或多个<strong>消费者</strong>线程，它们从缓冲区中取出数据（或任务）并进行处理。</li>
<li>生产者和消费者之间通过这个缓冲区进行<strong>解耦</strong>。</li>
</ul>
<p><strong>核心挑战</strong>：</p>
<ol>
<li><strong>缓冲区为空</strong>：消费者不能从空缓冲区取数据。</li>
<li><strong>缓冲区已满</strong>：生产者不能向已满的缓冲区放数据。</li>
<li><strong>竞态条件</strong>：对缓冲区的访问必须是互斥的，防止多个线程同时修改导致数据不一致。</li>
</ol>
<pre tabindex="0"><code>package main

import (
    &#34;fmt&#34;
    &#34;time&#34;
)

type Task struct {
    Runnable func(workerId int)
}

func main() {
    // 一个负责任务分发的管道
    ch := make(chan Task, 10)

    // 启动几个 worker 负责处理任务
    for id := range 10 {
        go func(workerId int) {
            for t := range ch {
                t.Runnable(workerId)
            }
        }(id)
    }

    // 任务分发
    for i := range 20 {
	    j := i
        t1 := Task{
            Runnable: func(workerId int) {
                fmt.Printf(&#34;workerId%v：task%v做一件事情\n&#34;, workerId, j)
            },
        }
        ch &lt;- t1
    }
    time.Sleep(1 * time.Second)
    close(ch)
}
</code></pre><p><strong>现实应用</strong>：</p>
<ul>
<li>消息队列（如Kafka, RabbitMQ）。</li>
<li>线程池任务调度。</li>
<li>Golang中的Channel，Java中的 <code>BlockingQueue</code> 其底层思想就是生产者-消费者模型。</li>
</ul>
<h2 id="2-读者-写者问题">2. 读者-写者问题<a hidden class="anchor" aria-hidden="true" href="#2-读者-写者问题">#</a></h2>
<p><strong>核心思想</strong>：在读多写少的问题中，对读写锁的使用，写锁类似于互斥锁，读锁类似于共享锁（能开多个）。</p>
<p><strong>读者</strong>只读取共享数据，不修改，<strong>写者</strong>会修改共享数据。<strong>允许多个读者同时读</strong>，但<strong>写者必须独占访问</strong>（即写时不能有读者或其他写者）。</p>
<p><strong>核心挑战</strong>：</p>
<ol>
<li>在保证数据一致性的前提下，最大限度地提高并发性（特别是对读者）。</li>
<li>可能导致<strong>写者饥饿</strong>：如果读者源源不断，写者可能永远无法获得访问权。</li>
</ol>
<pre tabindex="0"><code>package main

import (
	&#34;fmt&#34;
	&#34;sync&#34;
	&#34;time&#34;
)

func main() {
	var (
		data    int
		rwMutex sync.RWMutex // 读写锁
		wg      sync.WaitGroup
	)

	// 写者
	wg.Add(1)
	go func() {
		defer wg.Done()
		for i := 0; i &lt; 5; i++ {
			rwMutex.Lock() // 写锁
			data = i
			fmt.Printf(&#34;写入: %d\n&#34;, i)
			time.Sleep(time.Millisecond * 200)
			rwMutex.Unlock()
			time.Sleep(time.Millisecond * 100)
		}
	}()

	// 读者（多个）
	for i := 0; i &lt; 3; i++ {
		wg.Add(1)
		go func(id int) {
			defer wg.Done()
			for j := 0; j &lt; 5; j++ {
				rwMutex.RLock() // 读锁
				fmt.Printf(&#34;读者%d 读取: %d\n&#34;, id, data)
				time.Sleep(time.Millisecond * 50)
				rwMutex.RUnlock()
				time.Sleep(time.Millisecond * 100)
			}
		}(i)
	}

	wg.Wait()
}
</code></pre><p><strong>现实应用</strong>：</p>
<ul>
<li>数据库的并发控制。</li>
<li>文件系统、缓存的访问。</li>
</ul>
<h2 id="3-哲学家就餐问题">3. 哲学家就餐问题<a hidden class="anchor" aria-hidden="true" href="#3-哲学家就餐问题">#</a></h2>
<p><strong>核心思想</strong>：避免<strong>多个进程（或线程）竞争有限资源时</strong>的死锁问题，通过特定的策略(破坏循环)或限制并发度（筷子数量）等方法，解决死锁问题。</p>
<ul>
<li>五个哲学家围坐在一张圆桌旁，他们的一生只在做两件事：<strong>思考</strong>和<strong>吃饭</strong>。</li>
<li>桌上有五根筷子（不是五双），每两个哲学家之间有一根。</li>
<li>哲学家吃饭时需要同时拿起他<strong>左边和右边</strong>的筷子。</li>
<li>如果筷子在别人手里，他就必须等待。</li>
</ul>
<p><strong>核心挑战</strong>：</p>
<p><strong>死锁</strong>：如果所有哲学家同时感到饥饿，并同时拿起自己左边的筷子，那么所有人都会永远等待右边的筷子被释放，导致系统僵住。</p>
<pre tabindex="0"><code>package main

import (
	&#34;fmt&#34;
	&#34;sync&#34;
	&#34;time&#34;
)

func main() {
	// 5根筷子（互斥锁）
	chopsticks := make([]sync.Mutex, 5)
	var wg sync.WaitGroup

	// 哲学家函数
	philosopher := func(id int) {
		defer wg.Done()
		
		left := id
		right := (id + 1) % 5

		// 避免死锁：编号为偶数的哲学家先拿左边，奇数先拿右边
		for i := 0; i &lt; 3; i++ { // 吃3次
			if id%2 == 0 {
				chopsticks[left].Lock()
				chopsticks[right].Lock()
			} else {
				chopsticks[right].Lock()
				chopsticks[left].Lock()
			}

			// 拿到两根筷子，开始吃饭
			fmt.Printf(&#34;哲学家%d 正在吃饭...\n&#34;, id)
			time.Sleep(time.Millisecond * 100)

			// 放下筷子
			chopsticks[left].Unlock()
			chopsticks[right].Unlock()

			// 思考
			fmt.Printf(&#34;哲学家%d 正在思考...\n&#34;, id)
			time.Sleep(time.Millisecond * 100)
		}
	}

	// 启动5个哲学家
	for i := 0; i &lt; 5; i++ {
		wg.Add(1)
		go philosopher(i)
	}

	wg.Wait()
}
</code></pre><p><strong>现实应用</strong>：</p>
<p>任何需要获取多个互斥资源才能工作的场景，比如进程需要同时锁定多个数据库记录进行更新。</p>
<h2 id="4-理发师问题">4. 理发师问题<a hidden class="anchor" aria-hidden="true" href="#4-理发师问题">#</a></h2>
<p><strong>核心思想</strong>：模拟有容量限制的服务系统，通过<strong>空结构体</strong>(似乎叫信号量)来实现请求者与服务者的同步，并实现超容量时的拒绝和服务者的空闲/工作状态转换。</p>
<ul>
<li>一个理发店有一个理发师（服务线程）、一把理发椅（临界资源）和N把供顾客等待的椅子（等待队列）。</li>
<li>如果没有顾客，理发师就在理发椅上睡觉。</li>
<li>顾客到来时，如果理发师在睡觉，就叫醒他理发。</li>
<li>如果理发师在忙，顾客就坐在等待椅上等待。</li>
<li>如果等待椅也坐满了，顾客就会离开。</li>
</ul>
<p><strong>核心挑战</strong>：</p>
<ul>
<li>协调理发师（服务者）和顾客（请求者）的睡眠与唤醒。</li>
<li>管理有限的等待队列。</li>
</ul>
<pre tabindex="0"><code>package main

import (
	&#34;fmt&#34;
	&#34;math/rand&#34;
	&#34;sync&#34;
	&#34;time&#34;
)

func main() {
	// 理发店参数
	const (
		waitingChairs = 3 // 等待椅数量
		totalCustomers = 10 // 总顾客数
	)

	var (
		waitingRoom = make(chan struct{}, waitingChairs) // 等待室（缓冲channel）
		wg          sync.WaitGroup
		barberReady = make(chan struct{}, 1) // 理发师就绪信号
	)

	// 理发师
	wg.Add(1)
	go func() {
		defer wg.Done()
		for {
			select {
			case &lt;-waitingRoom:
				// 有顾客，开始理发
				barberReady &lt;- struct{}{} // 理发师准备就绪
				fmt.Println(&#34;理发师正在理发...&#34;)
				time.Sleep(time.Millisecond * 200) // 理发时间
				fmt.Println(&#34;理发完成！&#34;)
			default:
				// 没有顾客，睡觉
				fmt.Println(&#34;理发师在睡觉...&#34;)
				time.Sleep(time.Millisecond * 500)
			}
		}
	}()

	// 顾客
	for i := 0; i &lt; totalCustomers; i++ {
		wg.Add(1)
		go func(id int) {
			defer wg.Done()
			time.Sleep(time.Millisecond * time.Duration(rand.Intn(300)))

			select {
			case waitingRoom &lt;- struct{}{}:
				// 成功进入等待室
				fmt.Printf(&#34;顾客%d 在等待理发\n&#34;, id)
				&lt;-barberReady // 等待理发师就绪
				fmt.Printf(&#34;顾客%d 正在理发\n&#34;, id)
			default:
				// 等待室满了，离开
				fmt.Printf(&#34;顾客%d 看到等待室满了，离开了\n&#34;, id)
			}
		}(i)
	}

	// 等待所有顾客完成
	time.Sleep(time.Second * 3)
	fmt.Println(&#34;营业结束&#34;)
}
</code></pre><p><strong>现实应用</strong>：</p>
<p>线程池或服务器模型。例如，一个Web服务器有固定数量的工作线程（理发师）和一个最大连接队列（等待椅）。当新请求到达时，如果有空闲线程则立即处理，否则进入队列等待，如果队列也满了，则返回“服务器繁忙”错误。</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="prev" href="https://sheep44044.github.io/daily/2025-11-24-daily5/">
    <span class="title">« Prev</span>
    <br>
    <span>令人无语的goland和docker</span>
  </a>
  <a class="next" href="https://sheep44044.github.io/posts/2025-11-18-%E5%B9%B6%E5%8F%91/">
    <span class="title">Next »</span>
    <br>
    <span>并发</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2026 <a href="https://sheep44044.github.io/">sheep44044的小站</a></span> · 
        © 2025 我的网站 | <a href="/privacy">隐私政策</a> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
