<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Posts on sheep44044的小站</title>
    <link>https://sheep44044.github.io/posts/</link>
    <description>Recent content in Posts on sheep44044的小站</description>
    <generator>Hugo -- 0.147.4</generator>
    <language>zh-CN</language>
    <lastBuildDate>Sat, 20 Sep 2025 13:33:54 +0800</lastBuildDate>
    <atom:link href="https://sheep44044.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Golang的之接口</title>
      <link>https://sheep44044.github.io/posts/2025-09-19-interface/</link>
      <pubDate>Sat, 20 Sep 2025 13:33:54 +0800</pubDate>
      <guid>https://sheep44044.github.io/posts/2025-09-19-interface/</guid>
      <description>&lt;h1 id=&#34;golang之接口&#34;&gt;Golang之接口&lt;/h1&gt;
&lt;p&gt;接口是我在tour of go上遇到的第一个难点，因此我打算再开一篇来着重记录，不仅是当下对此的沉淀与思考，也是对未来的提醒与照应。为了方便自己的查看，便独立于之前的知识碎片。&lt;/p&gt;
&lt;h2 id=&#34;接口interface&#34;&gt;接口（interface）&lt;/h2&gt;
&lt;h3 id=&#34;接口的定义&#34;&gt;接口的定义&lt;/h3&gt;
&lt;p&gt;接口（Interface）本质上就是&lt;strong&gt;定义了一组方法签名（Method Signatures）的集合&lt;/strong&gt;。它只关心**“做什么”&lt;strong&gt;，而不关心&lt;/strong&gt;“怎么做”**。&lt;/p&gt;
&lt;p&gt;它规定：&lt;strong&gt;“任何类型，只要你实现了我的合同里规定的所有这些方法，那我就认为你实现了这个接口。”&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每个接口类型由任意个方法签名组成，接口的定义格式如下：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type 接口类型名 interface{
    方法名1( 参数列表1 ) 返回值列表1
    方法名2( 参数列表2 ) 返回值列表2
    …
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;如何实现接口隐式实现&#34;&gt;如何实现接口？（“隐式实现”）&lt;/h3&gt;
&lt;p&gt;Go 接口的实现是 &lt;strong&gt;“隐式”&lt;/strong&gt; 的。这意味着你&lt;strong&gt;不需要&lt;/strong&gt;像 Java 那样明确地写 &lt;code&gt;implements Speaker&lt;/code&gt;。只需要让这个类型拥有接口里规定的所有方法，它就自动实现了该接口！&lt;/p&gt;
&lt;p&gt;这是 Go 的哲学——“鸭子类型”（如果它走起来像鸭子，叫起来像鸭子，那它就是鸭子）。&lt;/p&gt;
&lt;h2 id=&#34;接口值&#34;&gt;接口值&lt;/h2&gt;
&lt;p&gt;接口也是值。它们可以像其它值一样传递。&lt;/p&gt;
&lt;p&gt;接口值可以用作函数的参数或返回值。&lt;/p&gt;
&lt;p&gt;接口值可以看作两部分&lt;strong&gt;具体类型&lt;/strong&gt;和&lt;strong&gt;该类型的值&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可以把接口值想象成一个特殊的“盒子”。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这个盒子上贴着一个&lt;strong&gt;标签&lt;/strong&gt;，写着里面装的东西的类型（&lt;code&gt;*main.Dog&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;盒子里装着&lt;strong&gt;实际的值&lt;/strong&gt;（一个 &lt;code&gt;Dog&lt;/code&gt; 结构体的实例）。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;var s Speaker      // 接口变量 s，此时它是一个空的“盒子”，里面是 nil
s = Dog{Name: &amp;#34;Rex&amp;#34;} // 赋值后，s 这个“盒子”里：
                     // - 标签：main.Dog
                     // - 值：{Rex}

fmt.Printf(&amp;#34;(%v, %T)\n&amp;#34;, s, s) // 输出：({Rex}, main.Dog)
                               // 值部分 和 类型部分
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当你调用 &lt;code&gt;s.Speak()&lt;/code&gt; 时，Go 会打开这个“盒子”，根据标签找到类型 &lt;code&gt;Dog&lt;/code&gt;，然后执行 &lt;code&gt;Dog&lt;/code&gt; 的 &lt;code&gt;Speak&lt;/code&gt; 方法。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Golang的知识碎片（基础篇）</title>
      <link>https://sheep44044.github.io/posts/first-post/</link>
      <pubDate>Sun, 14 Sep 2025 00:42:54 +0800</pubDate>
      <guid>https://sheep44044.github.io/posts/first-post/</guid>
      <description>&lt;h1 id=&#34;golang的知识碎片&#34;&gt;Golang的知识碎片&lt;/h1&gt;
&lt;p&gt;在此之前golang单纯看蓝山的文档，感觉学的很浅很零碎，所以打算重新看一遍。因为go by example、tour go和蓝山工作室的文档比较完善，所以下方将着重提及一些之前不太清楚的零碎知识，提醒自己。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;0.Go 语言的零值机制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在 Go 语言中，所有变量在声明时都会被自动初始化为其类型的&lt;strong&gt;零值&lt;/strong&gt;（zero value）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数值类型：&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;布尔类型：&lt;code&gt;false&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;字符串类型：&lt;code&gt;&amp;quot;&amp;quot;&lt;/code&gt;（空字符串）&lt;/li&gt;
&lt;li&gt;指针、接口、切片、映射、通道：&lt;code&gt;nil&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;结构体：每个字段都初始化为其类型的零值&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;1.变量声明&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;关于变量的声明包括两部分，类型和初始值，变量会从初始值中推断出类型或从类型中推断出初始值（即零值）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.返回值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Go 的返回值可以被命名（向前面的参数一样），return后面没有参数，就会返回没有命名的返回值&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.条件语句前简短语句&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;for和&lt;code&gt;if&lt;/code&gt; 语句可以在条件表达式前执行一个简短语句&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.无条件的switch&lt;/strong&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;switch {
case x &amp;lt; 0:
    fmt.Println(&amp;#34;Negative&amp;#34;)
case x == 0:
    fmt.Println(&amp;#34;Zero&amp;#34;)
default:
    fmt.Println(&amp;#34;Positive&amp;#34;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;5.defer推迟/defer栈&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;defer&lt;/code&gt; 语句会将函数调用推迟到外层函数返回之后执行&lt;/li&gt;
&lt;li&gt;被推迟的函数调用会被压入一个&lt;strong&gt;栈&lt;/strong&gt;中，当外层函数返回时，被推迟的函数会按照&lt;strong&gt;后进先出&lt;/strong&gt;（LIFO）的顺序执行&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;6.函数闭包&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;还没看懂，标记一下，感觉类似于递归？不懂&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;7.方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;方法可以看作有接收者的函数，不过带指针/值参数的函数必须接受一个指针/值，不然会报错，而以指针/值为接收者的方法被调用时，接收者既能为值又能为指针，不过能不能生效另说&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;8.接收者类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;接收者有两种类型，&lt;strong&gt;值接收者&lt;/strong&gt;和&lt;strong&gt;指针接收者&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用指针接收者的两个原因：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.方法需要修改接收者的值，值接收者只能改变副本，指针可以改变原始值&lt;/p&gt;
&lt;p&gt;2.提高效率，每次方法调用时，Go 需要将整个结构体的数据&lt;strong&gt;复制&lt;/strong&gt;一份给方法使用。如果结构体非常大，这个复制操作的开销会很大。而Go 只需要复制一个&lt;strong&gt;指针&lt;/strong&gt;（通常是一个机器字长的大小，如 8 字节），开销极小。&lt;/p&gt;
&lt;p&gt;所以，大部分的时候使用指针&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;tips&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于一个特定的类型，你应该决定是使用值接收者还是指针接收者，并&lt;strong&gt;为该类型的所有方法保持一致&lt;/strong&gt;。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
