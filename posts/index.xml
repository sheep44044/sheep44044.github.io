<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Posts on sheep44044的小站</title>
    <link>https://sheep44044.github.io/posts/</link>
    <description>Recent content in Posts on sheep44044的小站</description>
    <generator>Hugo -- 0.147.4</generator>
    <language>zh-CN</language>
    <lastBuildDate>Sun, 19 Oct 2025 14:42:57 +0800</lastBuildDate>
    <atom:link href="https://sheep44044.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Cookie Session Token理解笔记</title>
      <link>https://sheep44044.github.io/posts/2025-10-19-cookie/</link>
      <pubDate>Sun, 19 Oct 2025 14:42:57 +0800</pubDate>
      <guid>https://sheep44044.github.io/posts/2025-10-19-cookie/</guid>
      <description>&lt;p&gt;作为初学者，之前对于cookie、session和token的概念老是搞不清楚，现在搞懂了一些，就赶紧记下这一刻的知识，方便以后的查询。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;历史的演进是：&lt;code&gt;Cookie -&amp;gt; Session (基于Cookie) -&amp;gt; Token (尤其是JWT)&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;1-cookie&#34;&gt;1. Cookie&lt;/h2&gt;
&lt;p&gt;Cookie 本身不进行验证，它只是一个存储和传输机制，一个携带信息的工具。在session出现之前，Cookie直接存储用户信息，十分不安全。&lt;/p&gt;
&lt;h2 id=&#34;2-session&#34;&gt;2. Session&lt;/h2&gt;
&lt;p&gt;session一般结合cookie使用，是存储在服务器，它会在服务器储存相关信息，设置session并返回sessionid，sessionid存储在客户端，每次登陆用cookie带上sessionid，去寻找session验证。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Session 验证&lt;/strong&gt;：类似于“&lt;strong&gt;查账本&lt;/strong&gt;”的方式。服务器收到Session ID后，需要去数据库或内存中&lt;strong&gt;查找&lt;/strong&gt;这个ID对应的Session数据。&lt;/p&gt;
&lt;p&gt;因为需要为每个活跃用户存储一份数据，所以&lt;strong&gt;存储量 = 用户数量 × 每个用户的数据大小&lt;/strong&gt;，所以导致了技术上的限制：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Session数据存储在&lt;strong&gt;单个服务器&lt;/strong&gt;的内存中&lt;/li&gt;
&lt;li&gt;在集群环境中，请求可能被负载均衡到不同服务器&lt;/li&gt;
&lt;li&gt;除非所有服务器共享Session存储（如Redis），否则无法识别用户&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-token&#34;&gt;3. Token&lt;/h2&gt;
&lt;p&gt;token是存储在客户端的，相关信息存储在token的payload上，服务器只储存一个统一的密匙，用密匙进行验证。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;token验证&lt;/strong&gt;：类似于“&lt;strong&gt;验证人民币&lt;/strong&gt;”的方式。服务器中的密匙，根据token的header和payload验证签名。（header上的算法类似于开锁方法和说明书，密匙相当于那把钥匙，&lt;strong&gt;算法不等于密匙&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;因为只&lt;strong&gt;存储一份统一的密匙&lt;/strong&gt;，所以存储量是个常量，天生符合分布式系统。&lt;/p&gt;
&lt;h3 id=&#34;4安全性&#34;&gt;4.安全性&lt;/h3&gt;
&lt;p&gt;关于安全方面，不太清楚，就直接贴一下，AI的回答吧。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Session 的安全核心&lt;/strong&gt;是：Session ID 的&lt;strong&gt;保密性&lt;/strong&gt;。一旦泄露，攻击者可以完全冒充用户，直到服务器端主动使其失效。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Token 的安全核心&lt;/strong&gt;是：&lt;strong&gt;签名验证&lt;/strong&gt;和&lt;strong&gt;短生命周期&lt;/strong&gt;。它的设计一定程度上接受了“令牌可能会被偷”的现实，但通过技术手段限制其破坏力。&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    <item>
      <title>面向对象编程感悟</title>
      <link>https://sheep44044.github.io/posts/2025-09-30-oop/</link>
      <pubDate>Tue, 30 Sep 2025 00:40:06 +0800</pubDate>
      <guid>https://sheep44044.github.io/posts/2025-09-30-oop/</guid>
      <description>&lt;p&gt;面向对象，不知从何时起盘旋在我的脑海中，或许是学习Java，亦或是更早。不过，我一直都没特别理解这个东西，更不要说封装、继承等概念了，是我脑海中不断徘徊的乌云。直到现在，我重新审视，通过B站、知乎等网站，我终于有所感悟和理解，于是写下这篇文章。&lt;/p&gt;
&lt;p&gt;这里不着重于结构体和方法的理解和实现，只是单纯谈谈这个思想罢了👌&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;OOP即面向对象编程(Object Oriented Programming)&lt;/strong&gt;，与之相对的是面向过程编程。面向过程和面向对象的区别，用我在知乎上看到的一句话说就是——&lt;strong&gt;面向过程是编年体，面向对象是纪传体&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;面向过程&lt;/strong&gt;，关注的是做事，关注的是&amp;quot;步骤&amp;quot;。把要实现的事情，拆分成一个个步骤，依次完成。解决问题时，思考的是&amp;quot;先做什么，再做什么，最后做什么&amp;quot;。在我看来这个视角类似于实施者，由于生活中我们就是以这种思想来生活，所以不可避免的更熟悉和理解面向过程编程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;面向对象&lt;/strong&gt;则不一样，它关注的是对象，是找人。解决问题时，思考的是&amp;quot;这个问题中有哪些&lt;strong&gt;参与者&lt;/strong&gt;？这些参与者有哪些&lt;strong&gt;属性&lt;/strong&gt;和&lt;strong&gt;行为&lt;/strong&gt;？它们之间如何&lt;strong&gt;交互&lt;/strong&gt;？&amp;ldquo;在这里，面向对象先把事务分解到对象身上，描述各个对象的作用，然后才是他们之间的交互。这里的视角类似于管理者。&lt;/p&gt;
&lt;p&gt;基于这一思想，面向对象发展出&lt;strong&gt;封装、继承和多态&lt;/strong&gt;这三大特性。&lt;/p&gt;
&lt;p&gt;关于OOP的三特性形象化理解，假设你有一台洗衣机，要用它洗衣服，你关心它内部是怎么洗的么？你不关心，你只要按一个按钮就好了，这就是&lt;strong&gt;封装&lt;/strong&gt;。不同型号的洗衣机洗衣方式不同，但是都能洗衣，而且你也只关心洗衣机的这个洗衣功能而已，所以你可以将全部洗衣机进行抽象，最终抽象出一个接口洗衣机，它有一个方法洗衣，这就是&lt;strong&gt;多态&lt;/strong&gt;。相同品牌或者系列的洗衣机可能有类似的内部细节，这些细节可以组成一个模板，作为基类或者父类，而具体的某款产品则是子类，这是&lt;strong&gt;继承&lt;/strong&gt;。 使用时，你通过上下文取得洗衣机接口的一个实例，调用其的洗衣方法，你就可以完成洗衣服操作了。至于它是如何洗衣服的你压根不关心。这就是OOP。&lt;/p&gt;
&lt;p&gt;在面向对象编程的概念中，类、对象、方法和属性在Java中体现的尤为明显，在Golang中则有不同的实现方式。&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;传统OOP概念&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;Go中的实现&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;类(Class)&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;结构体(Struct)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;对象(Object)&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;结构体实例(Struct Instance)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;方法(Method)&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;带有接收者的函数(Method)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;属性(Fields)&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;结构体字段(Struct Fields)&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;1-封装&#34;&gt;1. 封装&lt;/h3&gt;
&lt;p&gt;Go使用结构体和方法实现封装：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;package&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;fmt&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 定义结构体（类似类）&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Person&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;name&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// 私有字段（小写开头）&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;Age&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 公共字段（大写开头）&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 结构体方法（接收者）&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;p&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;Person&lt;/span&gt;) &lt;span style=&#34;color:#a6e22e&#34;&gt;GetName&lt;/span&gt;() &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;p&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;name&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;p&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;Person&lt;/span&gt;) &lt;span style=&#34;color:#a6e22e&#34;&gt;SetName&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;name&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;p&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;name&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;name&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;p&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Person&lt;/span&gt;{}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;p&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;SetName&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Alice&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;p&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Age&lt;/span&gt; = &lt;span style=&#34;color:#ae81ff&#34;&gt;30&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;p&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;GetName&lt;/span&gt;()) &lt;span style=&#34;color:#75715e&#34;&gt;// 输出: Alice&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;p&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Age&lt;/span&gt;)       &lt;span style=&#34;color:#75715e&#34;&gt;// 输出: 30&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;2-组合替代继承&#34;&gt;2. 组合（替代继承）&lt;/h3&gt;
&lt;p&gt;Go使用组合而不是继承来实现代码复用：&lt;/p&gt;</description>
    </item>
    <item>
      <title>Golang之接口</title>
      <link>https://sheep44044.github.io/posts/2025-09-19-interface/</link>
      <pubDate>Sat, 20 Sep 2025 13:33:54 +0800</pubDate>
      <guid>https://sheep44044.github.io/posts/2025-09-19-interface/</guid>
      <description>&lt;h1 id=&#34;golang之接口&#34;&gt;Golang之接口&lt;/h1&gt;
&lt;p&gt;接口是我在tour of go上遇到的第一个难点，因此我打算再开一篇来着重记录，不仅是当下对此的沉淀与思考，也是对未来的提醒与照应。为了方便自己的查看，便独立于之前的知识碎片。&lt;/p&gt;
&lt;h2 id=&#34;接口interface&#34;&gt;接口（interface）&lt;/h2&gt;
&lt;h3 id=&#34;接口的定义&#34;&gt;接口的定义&lt;/h3&gt;
&lt;p&gt;接口（Interface）本质上就是&lt;strong&gt;定义了一组方法签名（Method Signatures）的集合&lt;/strong&gt;。它只关心**“做什么”&lt;strong&gt;，而不关心&lt;/strong&gt;“怎么做”**。&lt;/p&gt;
&lt;p&gt;它规定：&lt;strong&gt;“任何类型，只要你实现了我的合同里规定的所有这些方法，那我就认为你实现了这个接口。”&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每个接口类型由任意个方法签名组成，接口的定义格式如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;接口类型名&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;方法名1&lt;/span&gt;( &lt;span style=&#34;color:#a6e22e&#34;&gt;参数列表1&lt;/span&gt; ) &lt;span style=&#34;color:#a6e22e&#34;&gt;返回值列表1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;方法名2&lt;/span&gt;( &lt;span style=&#34;color:#a6e22e&#34;&gt;参数列表2&lt;/span&gt; ) &lt;span style=&#34;color:#a6e22e&#34;&gt;返回值列表2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;…&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;如何实现接口隐式实现&#34;&gt;如何实现接口？（“隐式实现”）&lt;/h3&gt;
&lt;p&gt;Go 接口的实现是 &lt;strong&gt;“隐式”&lt;/strong&gt; 的。这意味着你&lt;strong&gt;不需要&lt;/strong&gt;像 Java 那样明确地写 &lt;code&gt;implements Speaker&lt;/code&gt;。只需要让这个类型拥有接口里规定的所有方法，它就自动实现了该接口！&lt;/p&gt;
&lt;p&gt;这是 Go 的哲学——“鸭子类型”（如果它走起来像鸭子，叫起来像鸭子，那它就是鸭子）。&lt;/p&gt;
&lt;h2 id=&#34;接口值&#34;&gt;接口值&lt;/h2&gt;
&lt;p&gt;接口也是值。它们可以像其它值一样传递。&lt;/p&gt;
&lt;p&gt;接口值可以用作函数的参数或返回值。&lt;/p&gt;
&lt;p&gt;接口值可以看作两部分&lt;strong&gt;具体类型&lt;/strong&gt;和&lt;strong&gt;该类型的值&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可以把接口值想象成一个特殊的“盒子”。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这个盒子上贴着一个&lt;strong&gt;标签&lt;/strong&gt;，写着里面装的东西的类型（&lt;code&gt;*main.Dog&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;盒子里装着&lt;strong&gt;实际的值&lt;/strong&gt;（一个 &lt;code&gt;Dog&lt;/code&gt; 结构体的实例）。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Speaker&lt;/span&gt;      &lt;span style=&#34;color:#75715e&#34;&gt;// 接口变量 s，此时它是一个空的“盒子”，里面是 nil&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;Dog&lt;/span&gt;{&lt;span style=&#34;color:#a6e22e&#34;&gt;Name&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Rex&amp;#34;&lt;/span&gt;} &lt;span style=&#34;color:#75715e&#34;&gt;// 赋值后，s 这个“盒子”里：&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                     &lt;span style=&#34;color:#75715e&#34;&gt;// - 标签：main.Dog&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                     &lt;span style=&#34;color:#75715e&#34;&gt;// - 值：{Rex}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Printf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;(%v, %T)\n&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt;) &lt;span style=&#34;color:#75715e&#34;&gt;// 输出：({Rex}, main.Dog)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                               &lt;span style=&#34;color:#75715e&#34;&gt;// 值部分 和 类型部分&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当你调用 &lt;code&gt;s.Speak()&lt;/code&gt; 时，Go 会打开这个“盒子”，根据标签找到类型 &lt;code&gt;Dog&lt;/code&gt;，然后执行 &lt;code&gt;Dog&lt;/code&gt; 的 &lt;code&gt;Speak&lt;/code&gt; 方法。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Golang的知识碎片（基础篇）</title>
      <link>https://sheep44044.github.io/posts/first-post/</link>
      <pubDate>Sun, 14 Sep 2025 00:42:54 +0800</pubDate>
      <guid>https://sheep44044.github.io/posts/first-post/</guid>
      <description>&lt;h1 id=&#34;golang的知识碎片&#34;&gt;Golang的知识碎片&lt;/h1&gt;
&lt;p&gt;在此之前golang单纯看蓝山的文档，感觉学的很浅很零碎，所以打算重新看一遍。因为go by example、tour go和蓝山工作室的文档比较完善，所以下方将着重提及一些之前不太清楚的零碎知识，提醒自己。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;0.Go 语言的零值机制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在 Go 语言中，所有变量在声明时都会被自动初始化为其类型的&lt;strong&gt;零值&lt;/strong&gt;（zero value）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数值类型：&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;布尔类型：&lt;code&gt;false&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;字符串类型：&lt;code&gt;&amp;quot;&amp;quot;&lt;/code&gt;（空字符串）&lt;/li&gt;
&lt;li&gt;指针、接口、切片、映射、通道：&lt;code&gt;nil&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;结构体：每个字段都初始化为其类型的零值&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;1.变量声明&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;关于变量的声明包括两部分，类型和初始值，变量会从初始值中推断出类型或从类型中推断出初始值（即零值）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.返回值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Go 的返回值可以被命名（向前面的参数一样），return后面没有参数，就会返回没有命名的返回值&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.条件语句前简短语句&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;for和&lt;code&gt;if&lt;/code&gt; 语句可以在条件表达式前执行一个简短语句&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.无条件的switch(类似于if-else)&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;switch&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;x&lt;/span&gt; &amp;lt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Negative&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;x&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Zero&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;default&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Positive&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;5.defer推迟/defer栈&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;defer&lt;/code&gt; 语句会将函数调用推迟到外层函数返回之后执行&lt;/li&gt;
&lt;li&gt;被推迟的函数调用会被压入一个&lt;strong&gt;栈&lt;/strong&gt;中，当外层函数返回时，被推迟的函数会按照&lt;strong&gt;后进先出&lt;/strong&gt;（LIFO）的顺序执行&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;6.函数闭包&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;闭包 = 函数 + 外部变量变量&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;状态保持&lt;/strong&gt;：闭包可以记住并修改外部变量&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;独立实例&lt;/strong&gt;：每次调用外部函数都会创建新的闭包实例&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;实用性强&lt;/strong&gt;：用于需要保持状态的场景&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如何判断外部变量&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&amp;ldquo;这个变量是在内层函数内部定义的，还是外部定义的？&amp;rdquo;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;再问&lt;/strong&gt;：&amp;ldquo;内层函数是否使用了这个外部变量？&amp;rdquo;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;如果两个答案都是&amp;quot;是&amp;quot;&lt;/strong&gt;：那么这个变量就是被捕获的外部变量&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;7.方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;方法可以看作有接收者的函数，不过带指针/值参数的函数必须接受一个指针/值，不然会报错，而以指针/值为接收者的方法被调用时，接收者既能为值又能为指针，不过能不能生效另说&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;8.接收者类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;接收者有两种类型，&lt;strong&gt;值接收者&lt;/strong&gt;和&lt;strong&gt;指针接收者&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用指针接收者的两个原因：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.方法需要修改接收者的值，值接收者只能改变副本，指针可以改变原始值&lt;/p&gt;
&lt;p&gt;2.提高效率，每次方法调用时，Go 需要将整个结构体的数据&lt;strong&gt;复制&lt;/strong&gt;一份给方法使用。如果结构体非常大，这个复制操作的开销会很大。而Go 只需要复制一个&lt;strong&gt;指针&lt;/strong&gt;（通常是一个机器字长的大小，如 8 字节），开销极小。&lt;/p&gt;
&lt;p&gt;所以，大部分的时候使用指针&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;tips&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于一个特定的类型，你应该决定是使用值接收者还是指针接收者，并&lt;strong&gt;为该类型的所有方法保持一致&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;9.值类型/引用类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这是 Go 语言中一个非常重要的概念，决定了变量如何被分配内存、如何被赋值以及如何被传递给函数。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
