[{"content":"这个GitHub教育原来只是AI审核啊，怪不得我之前说了这么多人话，它都一秒给我拒了，我真是服了。这个AI太tm蠢了，怎么中文看不懂的，枉费我找了我的学生卡、学生证、录取通知书一点用都没有，还说了一大段话说我不用VPN连不上GitHub。\n最后还是在B站上取得真经。在备忘录里打了一段英文的话，说国庆节去旅游了所以ip在香港。最后，竟然过了。 哈哈哈～😂\n","permalink":"https://sheep44044.github.io/daily/2025-09-28-daily3/","summary":"\u003cp\u003e这个GitHub教育原来只是AI审核啊，怪不得我之前说了这么多人话，它都一秒给我拒了，我真是服了。这个AI太tm蠢了，怎么中文看不懂的，枉费我找了我的学生卡、学生证、录取通知书一点用都没有，还说了一大段话说我不用VPN连不上GitHub。\u003c/p\u003e\n\u003cp\u003e最后还是在B站上取得真经。在备忘录里打了一段英文的话，说国庆节去旅游了所以ip在香港。最后，竟然过了。 哈哈哈～😂\u003c/p\u003e","title":"愚蠢的我和GitHub教育"},{"content":"第三周学习总结 已完成事项 Go 语言学习 完成了 Tour of Go 的大部分练习。 但是也跳过了一些练习，image 接口等内容目前不急需；二叉查找树 等概念需要继续沉淀。 Go by Example 推进 已学习到 goroutine 的 rate-limiting 部分。 重点学习了闭包和goroutine及其timer、tickers、waitgroup 等内容。 但是也跳过了 范型、枚举、迭代器的 range 等目前不会的内容。 项目开发 - 智能笔记 开始完成智能笔记项目，准备一边学一边开发。 迈出第一步：成功让 API 服务运行起来。 Gin 框架学习 初步开始Gin的学习，掌握了 HTTP 方法、路由、路由参数、JSON、Query 和 Post Form 的使用。 计划在后续开发 JWT、日志 等功能时进行更深入的学习。 工具与环境 安装了 Postman、MySQL 等开发工具。 成功申请了 GitHub 教育福利（费了我好大劲，在使用 VPN 的情况下）。 下周计划 (可能) 项目开发继续 学习 SQL 基础语法。 初步学习 Gorm。 实现笔记的完整 CRUD 功能。 实现数据持久化，接入 MySQL 数据库。 学校课业（可能） 可能需要回顾学校知识，为 10 月中下旬 的期中考做准备。 ","permalink":"https://sheep44044.github.io/weekly/2025-09-29-weekly3/","summary":"\u003ch1 id=\"第三周学习总结\"\u003e第三周学习总结\u003c/h1\u003e\n\u003ch2 id=\"已完成事项\"\u003e已完成事项\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003eGo 语言学习\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e完成了 \u003ccode\u003eTour of Go\u003c/code\u003e 的大部分练习。\u003c/li\u003e\n\u003cli\u003e但是也跳过了一些练习，\u003ccode\u003eimage\u003c/code\u003e 接口等内容目前不急需；\u003ccode\u003e二叉查找树\u003c/code\u003e 等概念需要继续沉淀。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eGo by Example 推进\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e已学习到 \u003ccode\u003egoroutine\u003c/code\u003e 的 \u003ccode\u003erate-limiting\u003c/code\u003e 部分。\u003c/li\u003e\n\u003cli\u003e重点学习了\u003ccode\u003e闭包\u003c/code\u003e和\u003ccode\u003egoroutine\u003c/code\u003e及其\u003ccode\u003etimer\u003c/code\u003e、\u003ccode\u003etickers\u003c/code\u003e、\u003ccode\u003ewaitgroup\u003c/code\u003e 等内容。\u003c/li\u003e\n\u003cli\u003e但是也跳过了 \u003ccode\u003e范型\u003c/code\u003e、\u003ccode\u003e枚举\u003c/code\u003e、\u003ccode\u003e迭代器的 range\u003c/code\u003e 等目前不会的内容。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e项目开发 - 智能笔记\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e开始完成智能笔记项目，准备一边学一边开发。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e迈出第一步\u003c/strong\u003e：成功让 API 服务运行起来。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eGin 框架学习\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e初步开始Gin的学习，掌握了 \u003ccode\u003eHTTP 方法\u003c/code\u003e、\u003ccode\u003e路由\u003c/code\u003e、\u003ccode\u003e路由参数\u003c/code\u003e、\u003ccode\u003eJSON\u003c/code\u003e、\u003ccode\u003eQuery\u003c/code\u003e 和 \u003ccode\u003ePost Form\u003c/code\u003e 的使用。\u003c/li\u003e\n\u003cli\u003e计划在后续开发 \u003ccode\u003eJWT\u003c/code\u003e、\u003ccode\u003e日志\u003c/code\u003e 等功能时进行更深入的学习。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e工具与环境\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e安装了 \u003ccode\u003ePostman\u003c/code\u003e、\u003ccode\u003eMySQL\u003c/code\u003e 等开发工具。\u003c/li\u003e\n\u003cli\u003e成功申请了 \u003ccode\u003eGitHub 教育福利\u003c/code\u003e（费了我好大劲，在使用 VPN 的情况下）。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"下周计划-可能\"\u003e下周计划 (可能)\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e项目开发继续\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e学习 \u003ccode\u003eSQL\u003c/code\u003e 基础语法。\u003c/li\u003e\n\u003cli\u003e初步学习 \u003ccode\u003eGorm\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003e实现笔记的完整 \u003cstrong\u003eCRUD\u003c/strong\u003e 功能。\u003c/li\u003e\n\u003cli\u003e实现数据持久化，接入 \u003ccode\u003eMySQL\u003c/code\u003e 数据库。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e学校课业（可能）\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e可能\u003c/strong\u003e需要回顾学校知识，为 \u003cstrong\u003e10 月中下旬\u003c/strong\u003e 的期中考做准备。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e","title":"第三周总结"},{"content":"woc,这个gin的文档怎么这么傻逼啊，它的example的例子竟然是tm安照首字母排序的！我真的🙃蚌不住了，真的好笑，我🤡tm看了A开头的AsciiJSON半天，没搞懂gin的基础和它有什么关系。我还看了下面有什么自定义HTTP配置，日志文件什么的，我以为是我没怎么学net/http包的问题。屮，谁知道我前面几个都看不懂的无助感，真以为要被技术文档阻挡下来了，要中道崩殂了。\n幸好😅我问了ai，发现基础的是在后面的使用HTTP方法。复活了😑，耶🫠\u0026hellip;\n点\u0026mdash;\u0026gt;🤡\u0026lt;\u0026mdash;击\n好吧，其实我后面看了一下，它似乎是在quick start这里是正常的，按知识难度从基础到困难排的，不过它的注释是英文的，谷歌翻译翻译不到他，所以 一样\n","permalink":"https://sheep44044.github.io/daily/2025-09-26-daily2/","summary":"\u003cp\u003ewoc,这个gin的文档怎么这么傻逼啊，它的example的例子竟然是tm安照首字母排序的！我真的🙃蚌不住了，真的好笑，我🤡tm看了A开头的AsciiJSON半天，没搞懂gin的基础和它有什么关系。我还看了下面有什么自定义HTTP配置，日志文件什么的，我以为是我没怎么学net/http包的问题。屮，谁知道我前面几个都看不懂的无助感，真以为要被技术文档阻挡下来了，要中道崩殂了。\u003c/p\u003e\n\u003cp\u003e幸好😅我问了ai，发现基础的是在后面的使用HTTP方法。复活了😑，耶🫠\u0026hellip;\u003c/p\u003e\n\u003cp\u003e点\u0026mdash;\u0026gt;\u003ca href=\"https://gin-gonic.com/zh-cn/docs/\"\u003e🤡\u003c/a\u003e\u0026lt;\u0026mdash;击\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e好吧，其实我后面看了一下，它似乎是在quick start这里是正常的，按知识难度从基础到困难排的，不过它的注释是英文的，谷歌翻译翻译不到他，所以 一样\u003c/p\u003e","title":"fuck gin"},{"content":"woc，这个string 和 rune怎么这么麻烦😡，我有点看不懂了，以后再看吧👀\n现在先标记一下吧，以后看看(不过go的博客确实不赖，不过我现在太菜了，看不懂)\ngobyexample的字符串\nGo 中的字符串、字节、符文和字符\n","permalink":"https://sheep44044.github.io/daily/2025-09-23-daily1/","summary":"\u003cp\u003ewoc，这个string 和 rune怎么这么麻烦😡，我有点看不懂了，以后再看吧👀\u003c/p\u003e\n\u003cp\u003e现在先标记一下吧，以后看看(不过go的博客确实不赖，不过我现在太菜了，看不懂)\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://gobyexample.com/strings-and-runes\"\u003egobyexample的字符串\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://go.dev/blog/strings\"\u003eGo 中的字符串、字节、符文和字符\u003c/a\u003e\u003c/p\u003e","title":"巴拉巴拉"},{"content":"第二周总结 完成事项 解决了上周博客留下来的问题，有了一个简陋但功能完备的网站 🥳。 在 Tour of Go 上基本完成了所有内容的学习，包括切片、接口、并发等知识点。 持续推进 Go by Example 的学习，目前完成 switch 部分，进入数组相关内容（不得不说gobyexample确实不赖，对于这些基础知识我也能学到新的特性）。 做了一些学习笔记。 下周计划（可能） 巩固已学知识，搞懂 Tour of Go 中的练习题。 继续学习 Go by Example 的后续内容。 （可能）了解一些常用标准库包的基本用法。 ","permalink":"https://sheep44044.github.io/weekly/2025-09-22-weekly2/","summary":"\u003ch1 id=\"第二周总结\"\u003e第二周总结\u003c/h1\u003e\n\u003ch2 id=\"完成事项\"\u003e完成事项\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e解决了上周博客留下来的问题，有了一个简陋但功能完备的网站 🥳。\u003c/li\u003e\n\u003cli\u003e在 \u003ca href=\"https://tour.go-zh.org/\"\u003eTour of Go\u003c/a\u003e 上基本完成了所有内容的学习，包括切片、接口、并发等知识点。\u003c/li\u003e\n\u003cli\u003e持续推进 \u003ca href=\"https://gobyexample.com/\"\u003eGo by Example\u003c/a\u003e 的学习，目前完成 \u003ccode\u003eswitch\u003c/code\u003e 部分，进入数组相关内容（不得不说gobyexample确实不赖，对于这些基础知识我也能学到新的特性）。\u003c/li\u003e\n\u003cli\u003e做了一些学习笔记。\u003c/li\u003e\n\u003c/ol\u003e\n\u003chr\u003e\n\u003ch2 id=\"下周计划可能\"\u003e下周计划（可能）\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e巩固已学知识，搞懂 Tour of Go 中的练习题。\u003c/li\u003e\n\u003cli\u003e继续学习 Go by Example 的后续内容。\u003c/li\u003e\n\u003cli\u003e（可能）了解一些常用标准库包的基本用法。\u003c/li\u003e\n\u003c/ol\u003e","title":"第二周总结"},{"content":"Golang之接口 接口是我在tour of go上遇到的第一个难点，因此我打算再开一篇来着重记录，不仅是当下对此的沉淀与思考，也是对未来的提醒与照应。为了方便自己的查看，便独立于之前的知识碎片。\n接口（interface） 接口的定义 接口（Interface）本质上就是定义了一组方法签名（Method Signatures）的集合。它只关心**“做什么”，而不关心“怎么做”**。\n它规定：“任何类型，只要你实现了我的合同里规定的所有这些方法，那我就认为你实现了这个接口。”\n每个接口类型由任意个方法签名组成，接口的定义格式如下：\ntype 接口类型名 interface{ 方法名1( 参数列表1 ) 返回值列表1 方法名2( 参数列表2 ) 返回值列表2 … } 如何实现接口？（“隐式实现”） Go 接口的实现是 “隐式” 的。这意味着你不需要像 Java 那样明确地写 implements Speaker。只需要让这个类型拥有接口里规定的所有方法，它就自动实现了该接口！\n这是 Go 的哲学——“鸭子类型”（如果它走起来像鸭子，叫起来像鸭子，那它就是鸭子）。\n接口值 接口也是值。它们可以像其它值一样传递。\n接口值可以用作函数的参数或返回值。\n接口值可以看作两部分具体类型和该类型的值。\n可以把接口值想象成一个特殊的“盒子”。\n这个盒子上贴着一个标签，写着里面装的东西的类型（*main.Dog）。 盒子里装着实际的值（一个 Dog 结构体的实例）。 var s Speaker // 接口变量 s，此时它是一个空的“盒子”，里面是 nil s = Dog{Name: \u0026#34;Rex\u0026#34;} // 赋值后，s 这个“盒子”里： // - 标签：main.Dog // - 值：{Rex} fmt.Printf(\u0026#34;(%v, %T)\\n\u0026#34;, s, s) // 输出：({Rex}, main.Dog) // 值部分 和 类型部分 当你调用 s.Speak() 时，Go 会打开这个“盒子”，根据标签找到类型 Dog，然后执行 Dog 的 Speak 方法。\n底层值为 nil 的接口值 即便接口内的具体值为 nil，方法仍然会被 nil 接收者调用。保存了 nil 具体值的接口其自身并不为 nil。\nnil 接口值 nil 接口值既不保存值也不保存具体类型。\n为 nil 接口调用方法会产生运行时错误，因为接口的元组内并未包含能够指明该调用哪个 具体 方法的类型。\n空接口（interface{}/any） 空接口可保存任何类型的值（因为每个类型都至少实现了零个方法）\n空接口被用来处理未知类型的值\ntips：\n空接口是一个接口类型。因为它没有规定任何方法，所以Go语言规定所有类型都自动实现了空接口。\nnil接口值指的是一个接口变量的当前状态是“空”的。\n它们之间的关系是正交的：你可以有一个空接口类型的nil接口值，也可以有一个非空的自定义接口类型的nil接口值。\n类型断言 由于接口变量可以持有任意实现它的类型的值，有时我们需要知道它背后具体的实际值是什么。\n在 Go 语言中，接口断言是一种检查接口变量是否具有特定具体类型的方法。接口断言的基本语法如下：\nvalue, ok := interfaceVariable.(Type) 其中：\ninterfaceVariable 是一个接口类型的变量 Type 是你想要断言的具体类型 如果 interfaceVariable 实际上是一个 Type 类型的值，那么 value 将会被赋值为该值，并且 ok 将会是 true。如果 interfaceVariable 不是 Type 类型，那么 value 将会是 Type 类型的零值，而 ok 将会是 false 对于空接口 interface{}，任何类型的值都可以被赋值给它，因此对接口断言的需求更加常见 类型选择 类型选择 是一种按顺序从几个类型断言中选择分支的结构。\n类型选择与一般的 switch 语句相似，不过类型选择中的 case 为类型（而非值）， 它们针对给定接口值所存储的值的类型进行比较。\nswitch v := i.(type) { case T: // v 的类型为 T case S: // v 的类型为 S default: // 没有匹配，v 与 i 的类型相同 } 类型选择中的声明与类型断言 i.(T) 的语法相同，只是具体类型 T 被替换成了关键字 type。\n多态实现 接口变量可以持有任意实现它的类型的值\n多态（Polymorphism） 指的是一个接口的调用方式，可以在运行时根据其底层实际类型的不同而表现出不同的行为\n核心思想： 不同结构体只要实现了相同的接口，它们就可以被当作同一种类型（接口类型）来处理，但在执行接口方法时，会执行各自具体的实现。\n经典例子：\npackage main import \u0026#34;fmt\u0026#34; // 定义一个支付接口 type Payment interface { Pay(amount float64) string } // 实现两种不同的支付方式 type Alipay struct { Account string } func (a Alipay) Pay(amount float64) string { return fmt.Sprintf(\u0026#34;使用支付宝 %s 支付了 %.2f 元\u0026#34;, a.Account, amount) } type WechatPay struct { OpenID string } func (w WechatPay) Pay(amount float64) string { return fmt.Sprintf(\u0026#34;使用微信 %s 支付了 %.2f 元\u0026#34;, w.OpenID, amount) } // 一个通用的支付函数，它只关心传入的对象是否实现了 Payment 接口 func ProcessPayment(p Payment, amount float64) { result := p.Pay(amount) fmt.Println(result) } func main() { a := Alipay{Account: \u0026#34;zhangsan@alipay.com\u0026#34;} w := WechatPay{OpenID: \u0026#34;wx_abcdef123456\u0026#34;} // 多态的体现：ProcessPayment 函数不需要知道具体是哪种支付方式 // 它只需要调用 Pay 方法，而具体执行哪个版本的 Pay，由运行时 p 的实际类型决定 ProcessPayment(a, 100.5) ProcessPayment(w, 200.0) // 也可以将不同的实现放入同一个切片（接口类型切片） payments := []Payment{a, w} for _, payer := range payments { ProcessPayment(payer, 50.0) } } 输出：\n使用支付宝 zhangsan@alipay.com 支付了 100.50 元 使用微信 wx_abcdef123456 支付了 200.00 元 使用支付宝 zhangsan@alipay.com 支付了 50.00 元 使用微信 wx_abcdef123456 支付了 50.00 元 Go的\u0026quot;继承\u0026quot; Go 语言设计者认为传统的类继承（尤其是多重继承）模型复杂且容易出错。因此，Go 彻底摒弃了 class 和 extends 的概念。\nGo 的“继承”是通过结构体的嵌套（Embedding）来实现的，这本质上是“组合”。\n// “父类”（基类） type Animal struct { name string } func (a *Animal) Speak() { fmt.Println(\u0026#34;我是:\u0026#34;, a.name) } // “子类”（派生类），通过嵌入 Animal 来“继承”它的字段和方法 type Dog struct { Animal // 嵌入 Animal，实现了组合 Breed string // 子类自己的字段 } // 子类可以重写父类的方法 func (d *Dog) Speak() { d.Animal.Speak() // 可以调用“父类”的方法 fmt.Println(\u0026#34;汪汪汪！\u0026#34;) } func main() { d := Dog{ Animal: Animal{name: \u0026#34;旺财\u0026#34;}, // 初始化嵌入的结构体 Breed: \u0026#34;柯基\u0026#34;, } d.Speak() // 调用子类重写后的方法 d.Animal.Speak() // 仍然可以显式调用父类的方法 } 这种组合的优势：\n清晰简单：没有复杂的继承链。 解耦：Dog 和 Animal 是两个独立的类型，Dog 只是使用了 Animal 的功能。 灵活性：Dog 可以轻松组合多个其他结构体（例如 Pet）的功能，模拟了“多重继承”，但又没有多重继承的歧义问题。 常见的接口 1.Stringer fmt 包中定义的 Stringer 是最普遍的接口之一。\ntype Stringer interface { String() string } Stringer 是一个可以用字符串描述自己的类型。fmt 包（还有很多包）都通过此接口来打印值。\n2.error Go 程序使用 error 值来表示错误状态。\n与 fmt.Stringer 类似，error 类型是一个内建接口：\ntype error interface { Error() string } （与 fmt.Stringer 类似，fmt 包也会根据对 error 的实现来打印值。）\n通常函数会返回一个 error 值，调用它的代码应当判断这个错误是否等于 nil 来进行错误处理。\ni, err := strconv.Atoi(\u0026#34;42\u0026#34;) if err != nil { fmt.Printf(\u0026#34;couldn\u0026#39;t convert number: %v\\n\u0026#34;, err) return } fmt.Println(\u0026#34;Converted integer:\u0026#34;, i) error 为 nil 时表示成功；非 nil 的 error 表示失败。\n3.Readers io 包指定了 io.Reader 接口，它表示数据流的读取端。\nGo 标准库包含了该接口的许多实现，包括文件、网络连接、压缩和加密等等。\nio.Reader 接口有一个 Read 方法：\nfunc (T) Read(b []byte) (n int, err error) Read 用数据填充给定的字节切片并返回填充的字节数和错误值。在遇到数据流的结尾时，它会返回一个 io.EOF 错误。\n4.Image image 包定义了 Image 接口：\npackage image type Image interface { ColorModel() color.Model Bounds() Rectangle At(x, y int) color.Color } 注意: Bounds 方法的返回值 Rectangle 实际上是一个 image.Rectangle，它在 image 包中声明。\n","permalink":"https://sheep44044.github.io/posts/2025-09-19-interface/","summary":"\u003ch1 id=\"golang之接口\"\u003eGolang之接口\u003c/h1\u003e\n\u003cp\u003e接口是我在tour of go上遇到的第一个难点，因此我打算再开一篇来着重记录，不仅是当下对此的沉淀与思考，也是对未来的提醒与照应。为了方便自己的查看，便独立于之前的知识碎片。\u003c/p\u003e\n\u003ch2 id=\"接口interface\"\u003e接口（interface）\u003c/h2\u003e\n\u003ch3 id=\"接口的定义\"\u003e接口的定义\u003c/h3\u003e\n\u003cp\u003e接口（Interface）本质上就是\u003cstrong\u003e定义了一组方法签名（Method Signatures）的集合\u003c/strong\u003e。它只关心**“做什么”\u003cstrong\u003e，而不关心\u003c/strong\u003e“怎么做”**。\u003c/p\u003e\n\u003cp\u003e它规定：\u003cstrong\u003e“任何类型，只要你实现了我的合同里规定的所有这些方法，那我就认为你实现了这个接口。”\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e每个接口类型由任意个方法签名组成，接口的定义格式如下：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003etype 接口类型名 interface{\n    方法名1( 参数列表1 ) 返回值列表1\n    方法名2( 参数列表2 ) 返回值列表2\n    …\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"如何实现接口隐式实现\"\u003e如何实现接口？（“隐式实现”）\u003c/h3\u003e\n\u003cp\u003eGo 接口的实现是 \u003cstrong\u003e“隐式”\u003c/strong\u003e 的。这意味着你\u003cstrong\u003e不需要\u003c/strong\u003e像 Java 那样明确地写 \u003ccode\u003eimplements Speaker\u003c/code\u003e。只需要让这个类型拥有接口里规定的所有方法，它就自动实现了该接口！\u003c/p\u003e\n\u003cp\u003e这是 Go 的哲学——“鸭子类型”（如果它走起来像鸭子，叫起来像鸭子，那它就是鸭子）。\u003c/p\u003e\n\u003ch2 id=\"接口值\"\u003e接口值\u003c/h2\u003e\n\u003cp\u003e接口也是值。它们可以像其它值一样传递。\u003c/p\u003e\n\u003cp\u003e接口值可以用作函数的参数或返回值。\u003c/p\u003e\n\u003cp\u003e接口值可以看作两部分\u003cstrong\u003e具体类型\u003c/strong\u003e和\u003cstrong\u003e该类型的值\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e可以把接口值想象成一个特殊的“盒子”。\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e这个盒子上贴着一个\u003cstrong\u003e标签\u003c/strong\u003e，写着里面装的东西的类型（\u003ccode\u003e*main.Dog\u003c/code\u003e）。\u003c/li\u003e\n\u003cli\u003e盒子里装着\u003cstrong\u003e实际的值\u003c/strong\u003e（一个 \u003ccode\u003eDog\u003c/code\u003e 结构体的实例）。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003evar s Speaker      // 接口变量 s，此时它是一个空的“盒子”，里面是 nil\ns = Dog{Name: \u0026#34;Rex\u0026#34;} // 赋值后，s 这个“盒子”里：\n                     // - 标签：main.Dog\n                     // - 值：{Rex}\n\nfmt.Printf(\u0026#34;(%v, %T)\\n\u0026#34;, s, s) // 输出：({Rex}, main.Dog)\n                               // 值部分 和 类型部分\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e当你调用 \u003ccode\u003es.Speak()\u003c/code\u003e 时，Go 会打开这个“盒子”，根据标签找到类型 \u003ccode\u003eDog\u003c/code\u003e，然后执行 \u003ccode\u003eDog\u003c/code\u003e 的 \u003ccode\u003eSpeak\u003c/code\u003e 方法。\u003c/p\u003e","title":"Golang之接口"},{"content":"Golang的知识碎片 在此之前golang单纯看蓝山的文档，感觉学的很浅很零碎，所以打算重新看一遍。因为go by example、tour go和蓝山工作室的文档比较完善，所以下方将着重提及一些之前不太清楚的零碎知识，提醒自己。\n0.Go 语言的零值机制\n在 Go 语言中，所有变量在声明时都会被自动初始化为其类型的零值（zero value）：\n数值类型：0 布尔类型：false 字符串类型：\u0026quot;\u0026quot;（空字符串） 指针、接口、切片、映射、通道：nil 结构体：每个字段都初始化为其类型的零值 1.变量声明\n关于变量的声明包括两部分，类型和初始值，变量会从初始值中推断出类型或从类型中推断出初始值（即零值）\n2.返回值\nGo 的返回值可以被命名（向前面的参数一样），return后面没有参数，就会返回没有命名的返回值\n3.条件语句前简短语句\nfor和if 语句可以在条件表达式前执行一个简短语句\n4.无条件的switch(类似于if-else)\nswitch { case x \u0026lt; 0: fmt.Println(\u0026#34;Negative\u0026#34;) case x == 0: fmt.Println(\u0026#34;Zero\u0026#34;) default: fmt.Println(\u0026#34;Positive\u0026#34;) } 5.defer推迟/defer栈\ndefer 语句会将函数调用推迟到外层函数返回之后执行 被推迟的函数调用会被压入一个栈中，当外层函数返回时，被推迟的函数会按照后进先出（LIFO）的顺序执行 6.函数闭包\n闭包 = 函数 + 外部变量变量\n状态保持：闭包可以记住并修改外部变量 独立实例：每次调用外部函数都会创建新的闭包实例 实用性强：用于需要保持状态的场景 如何判断外部变量\n\u0026ldquo;这个变量是在内层函数内部定义的，还是外部定义的？\u0026rdquo; 再问：\u0026ldquo;内层函数是否使用了这个外部变量？\u0026rdquo; 如果两个答案都是\u0026quot;是\u0026quot;：那么这个变量就是被捕获的外部变量 7.方法\n方法可以看作有接收者的函数，不过带指针/值参数的函数必须接受一个指针/值，不然会报错，而以指针/值为接收者的方法被调用时，接收者既能为值又能为指针，不过能不能生效另说\n8.接收者类型\n接收者有两种类型，值接收者和指针接收者。\n使用指针接收者的两个原因：\n1.方法需要修改接收者的值，值接收者只能改变副本，指针可以改变原始值\n2.提高效率，每次方法调用时，Go 需要将整个结构体的数据复制一份给方法使用。如果结构体非常大，这个复制操作的开销会很大。而Go 只需要复制一个指针（通常是一个机器字长的大小，如 8 字节），开销极小。\n所以，大部分的时候使用指针\ntips\n对于一个特定的类型，你应该决定是使用值接收者还是指针接收者，并为该类型的所有方法保持一致。\n9.值类型/引用类型\n这是 Go 语言中一个非常重要的概念，决定了变量如何被分配内存、如何被赋值以及如何被传递给函数。\n值类型 (Value Types) 包括： 所有基本数据类型（如 int, float64, bool, string）、数组（Array）、结构体（struct）。 行为特点： 变量直接存储值本身。 赋值操作和函数传参时，会创建值的完整副本。 修改副本不会影响原始值。 在内存中，通常被分配在栈（Stack） 上（但编译器也可能决定分配在堆上）。 // 值类型示例：数组 arr1 := [3]int{1, 2, 3} arr2 := arr1 // 将 arr1 的【所有值】完整地复制一份给 arr2 arr2[0] = 100 // 修改副本 fmt.Println(arr1) // 输出: [1 2 3] (原值未改变) fmt.Println(arr2) // 输出: [100 2 3] 引用类型 (Reference Types) 包括： 切片（Slice）、映射（Map）、通道（Channel）、指针（Pointer）、函数（Function）。 行为特点： 变量存储的是一个“引用”（可以理解为内存地址），这个引用指向底层真正存储数据的内存空间。 赋值操作和函数传参时，复制的是这个“引用”（内存地址），而不是底层数据本身。 多个变量可以共享同一份底层数据。通过任何一个变量修改底层数据，其他所有引用它的变量都会“看到”这个变化。 底层数据通常存储在堆（Heap） 上。 // 引用类型示例：切片 slice1 := []int{1, 2, 3} slice2 := slice1 // 复制的是引用（地址），现在 slice1 和 slice2 指向同一个底层数组 slice2[0] = 100 // 通过 slice2 修改底层数组 fmt.Println(slice1) // 输出: [100 2 3] (原值被改变了！) fmt.Println(slice2) // 输出: [100 2 3] 总结对比表 特性 值类型 引用类型 代表类型 int, array, struct, string slice, map, channel, pointer 变量存储内容 实际的数据值 指向底层数据的地址（引用） 赋值/传参行为 复制整个数据值，创建独立副本 复制引用地址，共享底层数据 修改副本的影响 不影响原始数据 影响原始数据 内存主要位置 栈 堆（数据本身），变量本身可能在栈 10.匿名函数/结构体\u0026hellip;\n暂时不太懂，标记一下\n","permalink":"https://sheep44044.github.io/posts/first-post/","summary":"\u003ch1 id=\"golang的知识碎片\"\u003eGolang的知识碎片\u003c/h1\u003e\n\u003cp\u003e在此之前golang单纯看蓝山的文档，感觉学的很浅很零碎，所以打算重新看一遍。因为go by example、tour go和蓝山工作室的文档比较完善，所以下方将着重提及一些之前不太清楚的零碎知识，提醒自己。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e0.Go 语言的零值机制\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e在 Go 语言中，所有变量在声明时都会被自动初始化为其类型的\u003cstrong\u003e零值\u003c/strong\u003e（zero value）：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e数值类型：\u003ccode\u003e0\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e布尔类型：\u003ccode\u003efalse\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e字符串类型：\u003ccode\u003e\u0026quot;\u0026quot;\u003c/code\u003e（空字符串）\u003c/li\u003e\n\u003cli\u003e指针、接口、切片、映射、通道：\u003ccode\u003enil\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e结构体：每个字段都初始化为其类型的零值\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e1.变量声明\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e关于变量的声明包括两部分，类型和初始值，变量会从初始值中推断出类型或从类型中推断出初始值（即零值）\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e2.返回值\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eGo 的返回值可以被命名（向前面的参数一样），return后面没有参数，就会返回没有命名的返回值\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e3.条件语句前简短语句\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003efor和\u003ccode\u003eif\u003c/code\u003e 语句可以在条件表达式前执行一个简短语句\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e4.无条件的switch(类似于if-else)\u003c/strong\u003e\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eswitch {\ncase x \u0026lt; 0:\n    fmt.Println(\u0026#34;Negative\u0026#34;)\ncase x == 0:\n    fmt.Println(\u0026#34;Zero\u0026#34;)\ndefault:\n    fmt.Println(\u0026#34;Positive\u0026#34;)\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003e5.defer推迟/defer栈\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003edefer\u003c/code\u003e 语句会将函数调用推迟到外层函数返回之后执行\u003c/li\u003e\n\u003cli\u003e被推迟的函数调用会被压入一个\u003cstrong\u003e栈\u003c/strong\u003e中，当外层函数返回时，被推迟的函数会按照\u003cstrong\u003e后进先出\u003c/strong\u003e（LIFO）的顺序执行\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e6.函数闭包\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e闭包 = 函数 + 外部变量变量\u003c/strong\u003e\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e状态保持\u003c/strong\u003e：闭包可以记住并修改外部变量\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e独立实例\u003c/strong\u003e：每次调用外部函数都会创建新的闭包实例\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e实用性强\u003c/strong\u003e：用于需要保持状态的场景\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e如何判断外部变量\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u0026ldquo;这个变量是在内层函数内部定义的，还是外部定义的？\u0026rdquo;\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e再问\u003c/strong\u003e：\u0026ldquo;内层函数是否使用了这个外部变量？\u0026rdquo;\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e如果两个答案都是\u0026quot;是\u0026quot;\u003c/strong\u003e：那么这个变量就是被捕获的外部变量\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cstrong\u003e7.方法\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e方法可以看作有接收者的函数，不过带指针/值参数的函数必须接受一个指针/值，不然会报错，而以指针/值为接收者的方法被调用时，接收者既能为值又能为指针，不过能不能生效另说\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e8.接收者类型\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e接收者有两种类型，\u003cstrong\u003e值接收者\u003c/strong\u003e和\u003cstrong\u003e指针接收者\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e使用指针接收者的两个原因：\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e1.方法需要修改接收者的值，值接收者只能改变副本，指针可以改变原始值\u003c/p\u003e\n\u003cp\u003e2.提高效率，每次方法调用时，Go 需要将整个结构体的数据\u003cstrong\u003e复制\u003c/strong\u003e一份给方法使用。如果结构体非常大，这个复制操作的开销会很大。而Go 只需要复制一个\u003cstrong\u003e指针\u003c/strong\u003e（通常是一个机器字长的大小，如 8 字节），开销极小。\u003c/p\u003e\n\u003cp\u003e所以，大部分的时候使用指针\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003etips\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e对于一个特定的类型，你应该决定是使用值接收者还是指针接收者，并\u003cstrong\u003e为该类型的所有方法保持一致\u003c/strong\u003e。\u003c/p\u003e","title":"Golang的知识碎片（基础篇）"},{"content":"第一周总结 本周主要完成了以下三件事情：\n完成事项 熟悉 Mac 并配置软件环境\n开始熟悉 macOS 操作系统。 使用 Jetbrans Toolbox 安装 Goland 等开发工具。 通过 Homebrew 包管理器安装并管理 Git、Typora 等软件。 学习并使用 Git\n通过教程网站 learngitbranching.js.org 的git小游戏来学习和练习 Git 操作。 成功配置 Git 并与我的 GitHub 账户进行关联。 实现了在 Goland IDE 中集成并使用 Git。 利用 Hugo 搭建博客\n使用 Hugo 静态网站生成器初步搭建了个人博客。 实现了基本功能：主页文章展示、包含“文章”和“周报”等菜单的导航栏。 下周计划（可能） 解决博客的一个小问题：博客在互联网上登入时会错误跳转到本地。 复习 Golang 的知识。 ","permalink":"https://sheep44044.github.io/weekly/weekly-1/","summary":"\u003ch1 id=\"第一周总结\"\u003e第一周总结\u003c/h1\u003e\n\u003cp\u003e本周主要完成了以下三件事情：\u003c/p\u003e\n\u003ch2 id=\"完成事项\"\u003e完成事项\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e熟悉 Mac 并配置软件环境\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e开始熟悉 macOS 操作系统。\u003c/li\u003e\n\u003cli\u003e使用 Jetbrans Toolbox 安装 Goland 等开发工具。\u003c/li\u003e\n\u003cli\u003e通过 Homebrew 包管理器安装并管理 Git、Typora 等软件。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e学习并使用 Git\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e通过教程网站 \u003ca href=\"https://learngitbranching.js.org/?demo=\u0026amp;locale=zh_CN\"\u003elearngitbranching.js.org\u003c/a\u003e 的git小游戏来学习和练习 Git 操作。\u003c/li\u003e\n\u003cli\u003e成功配置 Git 并与我的 GitHub 账户进行关联。\u003c/li\u003e\n\u003cli\u003e实现了在 Goland IDE 中集成并使用 Git。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e利用 Hugo 搭建博客\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e使用 \u003ccode\u003eHugo\u003c/code\u003e 静态网站生成器初步搭建了个人博客。\u003c/li\u003e\n\u003cli\u003e实现了基本功能：主页文章展示、包含“文章”和“周报”等菜单的导航栏。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"下周计划可能\"\u003e下周计划（可能）\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e解决博客的一个小问题：博客在互联网上登入时会错误跳转到本地。\u003c/li\u003e\n\u003cli\u003e复习 Golang 的知识。\u003c/li\u003e\n\u003c/ul\u003e","title":"第一周总结"},{"content":"关于我 🥳\n我是 sheep44044，一名CQUPT的24级学生🧑‍🎓，一名对世界充满好奇的探索者。\n🚀 我正在学习：Git, Golang 以及其他有趣的开发技术。 📝 我正在记录：学习过程中的思考、总结和牢骚😩。 🎃 我的兴趣：代码、游戏、发呆ing。 🎯 展望\n提升自己 留点时间给自己 探索些感兴趣的东西 这个博客是我成长路上的数字脚印，也是你眼前看到的第一个小成果！旨在记录和分享我的学习历程与偶尔的碎碎念。如果这里的内容能给你带来一丝启发或帮助，那将是我最大的荣幸。\n💌 联系我：3290120053@qq.com\n🐙 GitHub: sheep44044\n感谢你的到访！期待与你交流。祝你今天过得愉快！✨\n","permalink":"https://sheep44044.github.io/about/","summary":"\u003cp\u003e关于我 🥳\u003c/p\u003e\n\u003cp\u003e我是 \u003cstrong\u003esheep44044\u003c/strong\u003e，一名CQUPT的24级学生🧑‍🎓，一名对世界充满好奇的探索者。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e🚀 \u003cstrong\u003e我正在学习\u003c/strong\u003e：Git, Golang 以及其他有趣的开发技术。\u003c/li\u003e\n\u003cli\u003e📝 \u003cstrong\u003e我正在记录\u003c/strong\u003e：学习过程中的思考、总结和牢骚😩。\u003c/li\u003e\n\u003cli\u003e🎃 \u003cstrong\u003e我的兴趣\u003c/strong\u003e：代码、游戏、发呆ing。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e🎯 展望\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e提升自己\u003c/li\u003e\n\u003cli\u003e留点时间给自己\u003c/li\u003e\n\u003cli\u003e探索些感兴趣的东西\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e这个博客是我成长路上的数字脚印，也是你眼前看到的第一个小成果！旨在记录和分享我的学习历程与偶尔的碎碎念。如果这里的内容能给你带来一丝启发或帮助，那将是我最大的荣幸。\u003c/p\u003e\n\u003cp\u003e💌 \u003cstrong\u003e联系我\u003c/strong\u003e：\u003ccode\u003e3290120053@qq.com\u003c/code\u003e\u003cbr\u003e\n🐙 \u003cstrong\u003eGitHub\u003c/strong\u003e: \u003ca href=\"https://github.com/sheep44044\"\u003esheep44044\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e感谢你的到访！期待与你交流。祝你今天过得愉快！✨\u003c/p\u003e","title":"关于我"},{"content":"种一棵树最好的时间是十年前，其次是现在。 大一的时候，我初出茅庐，渴望着完美，绩点、开发、算法一并取得，最后什么都没拿到。\n现在，希望专注于一点，取得一丝成就吧。\n— 2025.9.13\n只有选择，没有对错，喜欢的事，勇敢去做，不要怕，不喜欢的事，尽力而为，听从自己内心的选择。\n在网上，人们说大学最好的时光是在高中时，最好的高中时光在大学生活中。回顾高中三年，我却难以会想起我自身的成就和生活的美好，就连学习也没有学到什么——周末、寒暑去补课，最终，却还是需要父母的帮助才来到重邮。\n悟以往之不谏，知来者之可追。我希望能通过日记来记录自己的学习，亦是提醒自己不要忘记过去的遗憾和那每年的30000元学费。\n我希望能通过自己的蜕变，逐渐成长，达成以下目标：\n拿到奖学金 通过红岩和蓝山的考核 进入ACM集训队 拿到地区的奖牌 获得浙大的录取通知书或是大厂的offer 虽然我的目标实现十分困难，也没有任何实现的依据。但是，我希望借此来激发自己，成为别人口中聪明的孩子，对得起父母、自己和每年的30000元。\n这些想法积聚我脑中已久，借此，我想放空我的脑袋，把这些情绪与计划一同放于日记中，付诸更多的行动，来更好地学习。至于对象、健身这些对我虚无缥缈的东西，尽力而为吧。\nFIGHTing — 2024.11.8\n","permalink":"https://sheep44044.github.io/daily/my-first-post/","summary":"\u003ch1 id=\"种一棵树最好的时间是十年前其次是现在\"\u003e种一棵树最好的时间是十年前，其次是现在。\u003c/h1\u003e\n\u003cp\u003e大一的时候，我初出茅庐，渴望着完美，绩点、开发、算法一并取得，最后什么都没拿到。\u003c/p\u003e\n\u003cp\u003e现在，希望专注于一点，取得一丝成就吧。\u003cbr\u003e\n— 2025.9.13\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e只有选择，没有对错，喜欢的事，勇敢去做，不要怕，不喜欢的事，尽力而为，听从自己内心的选择。\u003c/p\u003e\n\u003cp\u003e在网上，人们说大学最好的时光是在高中时，最好的高中时光在大学生活中。回顾高中三年，我却难以会想起我自身的成就和生活的美好，就连学习也没有学到什么——周末、寒暑去补课，最终，却还是需要父母的帮助才来到重邮。\u003c/p\u003e\n\u003cp\u003e悟以往之不谏，知来者之可追。我希望能通过日记来记录自己的学习，亦是提醒自己不要忘记过去的遗憾和那每年的30000元学费。\u003c/p\u003e\n\u003cp\u003e我希望能通过自己的蜕变，逐渐成长，达成以下目标：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e拿到奖学金\u003c/li\u003e\n\u003cli\u003e通过红岩和蓝山的考核\u003c/li\u003e\n\u003cli\u003e进入ACM集训队\u003c/li\u003e\n\u003cli\u003e拿到地区的奖牌\u003c/li\u003e\n\u003cli\u003e获得浙大的录取通知书或是大厂的offer\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e虽然我的目标实现十分困难，也没有任何实现的依据。但是，我希望借此来激发自己，成为别人口中聪明的孩子，对得起父母、自己和每年的30000元。\u003c/p\u003e\n\u003cp\u003e这些想法积聚我脑中已久，借此，我想放空我的脑袋，把这些情绪与计划一同放于日记中，付诸更多的行动，来更好地学习。至于对象、健身这些对我虚无缥缈的东西，尽力而为吧。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eFIGHTing\u003c/strong\u003e       — 2024.11.8\u003c/p\u003e","title":"My First Post"}]