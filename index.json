[{"content":"考试考完了！！！\n考试考完了！！\n考试考完了！\n复活了！\n复活了！！\n复活了！！！\n","permalink":"https://sheep44044.github.io/weekly/2026-01-21-25%E7%A7%8Bweekly19/","summary":"\u003cp\u003e考试考完了！！！\u003c/p\u003e\n\u003cp\u003e考试考完了！！\u003c/p\u003e\n\u003cp\u003e考试考完了！\u003c/p\u003e\n\u003cp\u003e复活了！\u003c/p\u003e\n\u003cp\u003e复活了！！\u003c/p\u003e\n\u003cp\u003e复活了！！！\u003c/p\u003e","title":"第十九周总结"},{"content":"今天是2026.1.21，考试月结束了。我终于完成了所有的期末考，回到了我心爱的家，与妈妈闲聊后，正躺在我最舒服的大床上，在热水袋的暖气包裹下，我在Mac上打下文字。\n回顾着这一个学期，现在感觉起来确实挺短暂的，毕竟在我13.5年的学习生涯中，这一学期仅占据了1/27而已，但是对我而言却是短暂但充实的。\n我从安装Goland开始，跟着蓝山的课程学习，踏上tour of go道路，学习了gin，了解了gorm，安装了mysql、redis，运行了docker，实践了rabbitMQ和ai\u0026hellip;\u0026hellip;我完成了绝大部分的蓝山作业，我拥有了个简陋的crud的项目，我更能理解牛客中被分享的简历的内容和含义，我甚至感觉我也可以做到他们的一部分内容。我觉得我可以再努力一点，勤能补拙，不过不知道一年能赶上两年的多少呢？0.6？0.7？不过我希望能追上越来越多！\n在知乎上，我时常会看到大家分享这个学期的学习和历练，9月会做什么、10月会做什么\u0026hellip;\u0026hellip;我觉得这是一个不错的方式，这能够警醒自己要保持动力所以我开始写周报。这确实发挥了一部分作用，我在某些时候确实挺认真的，但是在完美主义的作用下，像一辆不断加速的汽车，最终报废了。所以，我也在某些时刻颓废了，生无可恋了，失去激情了，学不动了。希望下学期，我能够更好地掌握自己的身体，管理时间，做到无限能源，一直冲冲冲。\n最近，喜欢看《凡人修仙传》，我觉得高中是最像修仙的时候，成绩就对应着修仙的实力，不是你死就是我亡。web从某种角度看也差不多，实习、项目、算法、八股和奖项都需要我们去努力争取，寻得一份机缘。有的人前端学院本却凭借多段实习，拿到众多大厂的ssp的offer；有的人到大四时依然还在谋求一份实习，简历石沉大海，被学历和自身的视野所困住，像极了修仙无门的人，恰如墨彩环感慨的，“韩大哥，没有灵根，真的不能修仙吗？”\n最后，响起pv：这一路破空 苦难有千重 谁人懂 只求有朝再相逢\n​\t修炼尘世中 缘仇万事空 都目送 终究不平凡不平庸\n下学期继续努力吧\n","permalink":"https://sheep44044.github.io/daily/2026-01-21-%E5%AD%A6%E6%9C%9F%E6%80%BB%E7%BB%93/","summary":"\u003cp\u003e今天是2026.1.21，考试月结束了。我终于完成了所有的期末考，回到了我心爱的家，与妈妈闲聊后，正躺在我最舒服的大床上，在热水袋的暖气包裹下，我在Mac上打下文字。\u003c/p\u003e\n\u003cp\u003e回顾着这一个学期，现在感觉起来确实挺短暂的，毕竟在我13.5年的学习生涯中，这一学期仅占据了1/27而已，但是对我而言却是短暂但充实的。\u003c/p\u003e\n\u003cp\u003e我从安装Goland开始，跟着蓝山的课程学习，踏上tour of go道路，学习了gin，了解了gorm，安装了mysql、redis，运行了docker，实践了rabbitMQ和ai\u0026hellip;\u0026hellip;我完成了绝大部分的蓝山作业，我拥有了个简陋的crud的项目，我更能理解牛客中被分享的简历的内容和含义，我甚至感觉我也可以做到他们的一部分内容。我觉得我可以再努力一点，勤能补拙，不过不知道一年能赶上两年的多少呢？0.6？0.7？不过我希望能追上越来越多！\u003c/p\u003e\n\u003cp\u003e在知乎上，我时常会看到大家分享这个学期的学习和历练，9月会做什么、10月会做什么\u0026hellip;\u0026hellip;我觉得这是一个不错的方式，这能够警醒自己要保持动力所以我开始写周报。这确实发挥了一部分作用，我在某些时候确实挺认真的，但是在完美主义的作用下，像一辆不断加速的汽车，最终报废了。所以，我也在某些时刻颓废了，生无可恋了，失去激情了，学不动了。希望下学期，我能够更好地掌握自己的身体，管理时间，做到无限能源，一直冲冲冲。\u003c/p\u003e\n\u003cp\u003e最近，喜欢看《凡人修仙传》，我觉得高中是最像修仙的时候，成绩就对应着修仙的实力，不是你死就是我亡。web从某种角度看也差不多，实习、项目、算法、八股和奖项都需要我们去努力争取，寻得一份机缘。有的人前端学院本却凭借多段实习，拿到众多大厂的ssp的offer；有的人到大四时依然还在谋求一份实习，简历石沉大海，被学历和自身的视野所困住，像极了修仙无门的人，恰如墨彩环感慨的，“韩大哥，没有灵根，真的不能修仙吗？”\u003c/p\u003e\n\u003cp\u003e最后，响起pv：这一路破空 苦难有千重 谁人懂 只求有朝再相逢\u003c/p\u003e\n\u003cp\u003e​\t\t\t修炼尘世中 缘仇万事空 都目送 终究不平凡不平庸\u003c/p\u003e\n\u003cp\u003e下学期继续努力吧\u003c/p\u003e","title":"2025秋 学期总结"},{"content":" 这周由于生病+六级考试的原因，其实没什么时间学习，不过倒也做了一点和学了点东西。不过马上就要期末考了，之后估计主要去看大物和概率论了(备考压力还是有点大的)，可能偶尔会继续学习吧\u0026hellip;\n还有好多要学习啊🥲，docker、消息队列、微服务、八股、算法\u0026hellip;\u0026hellip;感觉学前都很难、学后就觉得是简单的掉包罢了(虽然事实如此)，人果然不能共情自己\n已完成事项 这周主要是对我的小项目完成了暂时的功能(业务?)设计的实现，包括用分页展示note的社区(之后可能会用游标)、所有展示笔记类似的功能(像返回最近记录、展示star的内容、获取关注的人的笔记推送等)、实现关注和取关的功能。 优化并修复了些代码，像把redis的实现从全局变量这种简单粗暴的方式改为了依赖注入，更加严谨一点 了解了一些消息队列的还是，在小项目中成功连接了rabbitMQ，初步学习了相关文档，准备进一步的学习后进行部署和应用 下周计划 学习和应用rabbitMQ 学习和使用docker ","permalink":"https://sheep44044.github.io/weekly/2025-12-15-weekly14/","summary":"\u003cblockquote\u003e\n\u003cp\u003e这周由于生病+六级考试的原因，其实没什么时间学习，不过倒也做了一点和学了点东西。不过马上就要期末考了，之后估计主要去看大物和概率论了(备考压力还是有点大的)，可能偶尔会继续学习吧\u0026hellip;\u003c/p\u003e\n\u003cp\u003e还有好多要学习啊🥲，docker、消息队列、微服务、八股、算法\u0026hellip;\u0026hellip;感觉学前都很难、学后就觉得是简单的掉包罢了(虽然事实如此)，人果然不能共情自己\u003c/p\u003e\u003c/blockquote\u003e\n\u003ch2 id=\"已完成事项\"\u003e已完成事项\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e这周主要是对我的小项目完成了暂时的功能(业务?)设计的实现，包括用分页展示note的社区(之后可能会用游标)、所有展示笔记类似的功能(像返回最近记录、展示star的内容、获取关注的人的笔记推送等)、实现关注和取关的功能。\u003c/li\u003e\n\u003cli\u003e优化并修复了些代码，像把redis的实现从全局变量这种简单粗暴的方式改为了依赖注入，更加严谨一点\u003c/li\u003e\n\u003cli\u003e了解了一些消息队列的还是，在小项目中成功连接了rabbitMQ，初步学习了相关文档，准备进一步的学习后进行部署和应用\u003c/li\u003e\n\u003c/ol\u003e\n\u003chr\u003e\n\u003ch2 id=\"下周计划\"\u003e下周计划\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e学习和应用rabbitMQ\u003c/li\u003e\n\u003cli\u003e学习和使用docker\u003c/li\u003e\n\u003c/ol\u003e","title":"第十四周总结"},{"content":" 由于上周还是上上周，我提过这版的goland内置API过低连接不上docker，因为懒得回退版本，所以没有选择去看docker，这周我主要是一直在为小项目添砖加瓦吧，完成了user的全部功能，给note也添加了部分功能，其实现在看虽然不是完成品，但我感觉也很不赖了。其实完成一个小项目确实不是什么难事，只需要回最基础的gin+gorm和强大的AI即可\n现在看什么笔记，备忘录，文档确实是差不多东西的玩意儿\nGO～（摩托声）\n已完成事项 完成了所有user需要的功能(自认为，仅限后端部分)，包括这周完成的修改密码、个人主页部分，和之前已经完成的注册、登入和登出 完成了一些note的功能，包括添加了简单的搜索功能、置顶功能、点赞(收藏/star)功能、添加isprivate和favoritecount字段，为未来我伟大的explore/community功能打下伏笔（不过这样看怎么有点像小红书了？），还有一两个还没完成的功能。(不过AI建议我还要加上事务等工具完善，现在太简陋了😭) 查询了一下，发现note的一些功能是需要与前端合作的，像自动保存和富文本，只能暂且放下(怪不得cyjj没完成这些) 下周计划 Goland更新了！修复好了连接docker的bug，或许学学docker 或许继续完善功能(感觉单靠gin+gorm+redis快要到极限了) ","permalink":"https://sheep44044.github.io/weekly/2025-12-08-weekly13/","summary":"\u003cblockquote\u003e\n\u003cp\u003e由于上周还是上上周，我提过这版的goland内置API过低连接不上docker，因为懒得回退版本，所以没有选择去看docker，这周我主要是一直在为小项目添砖加瓦吧，完成了user的全部功能，给note也添加了部分功能，其实现在看虽然不是完成品，但我感觉也很不赖了。其实完成一个小项目确实不是什么难事，只需要回最基础的gin+gorm和强大的AI即可\u003c/p\u003e\n\u003cp\u003e现在看什么笔记，备忘录，文档确实是差不多东西的玩意儿\u003c/p\u003e\n\u003cp\u003eGO～（摩托声）\u003c/p\u003e\u003c/blockquote\u003e\n\u003ch2 id=\"已完成事项\"\u003e已完成事项\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e完成了所有user需要的功能(自认为，仅限后端部分)，包括这周完成的修改密码、个人主页部分，和之前已经完成的注册、登入和登出\u003c/li\u003e\n\u003cli\u003e完成了一些note的功能，包括添加了简单的搜索功能、置顶功能、点赞(收藏/star)功能、添加isprivate和favoritecount字段，为未来我伟大的explore/community功能打下伏笔（不过这样看怎么有点像小红书了？），还有一两个还没完成的功能。(不过AI建议我还要加上事务等工具完善，现在太简陋了😭)\u003c/li\u003e\n\u003cli\u003e查询了一下，发现note的一些功能是需要与前端合作的，像自动保存和富文本，只能暂且放下(怪不得cyjj没完成这些)\u003c/li\u003e\n\u003c/ol\u003e\n\u003chr\u003e\n\u003ch2 id=\"下周计划\"\u003e下周计划\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003eGoland更新了！修复好了连接docker的bug，或许学学docker\u003c/li\u003e\n\u003cli\u003e或许继续完善功能(感觉单靠gin+gorm+redis快要到极限了)\u003c/li\u003e\n\u003c/ol\u003e","title":"第十三周总结"},{"content":" 这周，我实践的不是很多，只是在上周完成了redis的应用部署情况下继续部署。在回顾整个项目时也是发现了新的感悟和不足，redis虽然也叫数据库，但更多是进行性能优化的功能，如果是一个小项目只用gin和gorm就够了。我现在发现虽然我知道了中间件的洋葱模型，但我不太理解他在整个过程中的逻辑思路，并且发现了一些其他的不足\n我好菜啊\u0026hellip;🥲\n已完成事项 用redis进行了更多的部署，包括用户会话管理(加上了黑名单)，实现了登出功能。 设置了随机过期时间防止雪崩，了解了防击穿(我现在似乎用不上所以只知道是用redis的锁)，实行了降级策略（避免redis挂了，程序无法运行） 实现了最近访问记录功能 回顾了整个代码（之前有点囫囵吞枣，像jwt的一些方法我都不太了解）。记住了一些常用的方法：json包里的marshal和Unmarshal([]byte和数据结构的转换),，jwt包的parse(需要的密匙，非要用函数作为参数来传递)和ParseUnverified(有三个返回值了还能填充claims，太高级了) 在实现相关功能时了解了一些go-redis的api(其实感觉和redis操作差不多，方法名字都一样，不过老是要使用context参数和结尾加个result()有点麻烦，所以去封装了一下，不过封装多了感觉其实差不多) 做了一道力扣😄 下周计划 没想好，哈哈哈 ","permalink":"https://sheep44044.github.io/weekly/2025-12-01-weekly12/","summary":"\u003cblockquote\u003e\n\u003cp\u003e这周，我实践的不是很多，只是在上周完成了redis的应用部署情况下继续部署。在回顾整个项目时也是发现了新的感悟和不足，redis虽然也叫数据库，但更多是进行性能优化的功能，如果是一个小项目只用gin和gorm就够了。我现在发现虽然我知道了中间件的洋葱模型，但我不太理解他在整个过程中的逻辑思路，并且发现了一些其他的不足\u003c/p\u003e\n\u003cp\u003e我好菜啊\u0026hellip;🥲\u003c/p\u003e\u003c/blockquote\u003e\n\u003ch2 id=\"已完成事项\"\u003e已完成事项\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e用redis进行了更多的部署，包括用户会话管理(加上了黑名单)，实现了登出功能。\u003c/li\u003e\n\u003cli\u003e设置了随机过期时间防止雪崩，了解了防击穿(我现在似乎用不上所以只知道是用redis的锁)，实行了降级策略（避免redis挂了，程序无法运行）\u003c/li\u003e\n\u003cli\u003e实现了最近访问记录功能\u003c/li\u003e\n\u003cli\u003e回顾了整个代码（之前有点囫囵吞枣，像jwt的一些方法我都不太了解）。记住了一些常用的方法：json包里的\u003ccode\u003emarshal\u003c/code\u003e和\u003ccode\u003eUnmarshal\u003c/code\u003e([]byte和数据结构的转换),，jwt包的\u003ccode\u003eparse\u003c/code\u003e(需要的密匙，非要用函数作为参数来传递)和\u003ccode\u003eParseUnverified\u003c/code\u003e(有三个返回值了还能填充claims，太高级了)\u003c/li\u003e\n\u003cli\u003e在实现相关功能时了解了一些\u003ccode\u003ego-redis的api\u003c/code\u003e(其实感觉和redis操作差不多，方法名字都一样，不过老是要使用context参数和结尾加个result()有点麻烦，所以去封装了一下，不过封装多了感觉其实差不多)\u003c/li\u003e\n\u003cli\u003e做了一道力扣😄\u003c/li\u003e\n\u003c/ol\u003e\n\u003chr\u003e\n\u003ch2 id=\"下周计划\"\u003e下周计划\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e没想好，哈哈哈\u003c/li\u003e\n\u003c/ol\u003e","title":"第十二周总结"},{"content":"1. 两数之和\n给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。\n你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。\n你可以按任意顺序返回答案。\n示例 1：\n输入：nums = [2,7,11,15], target = 9 输出：[0,1] 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。\n示例 2：\n输入：nums = [3,2,4], target = 6 输出：[1,2]\n示例 3：\n输入：nums = [3,3], target = 6 输出：[0,1]\n哈希表 func twoSum(nums []int, target int) []int { for i := 0; i \u0026lt; len(nums); i++ { for j := i + 1; j \u0026lt; len(nums); j++ { if nums[i] + nums[j] == target { return []int{i, j} } } } return nil } ","permalink":"https://sheep44044.github.io/leetcode/leetcode-1.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/","summary":"\u003cp\u003e\u003ca href=\"https://leetcode.cn/problems/two-sum/\"\u003e\u003cstrong\u003e1. 两数之和\u003c/strong\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e给定一个整数数组 \u003ccode\u003enums\u003c/code\u003e 和一个整数目标值 \u003ccode\u003etarget\u003c/code\u003e，请你在该数组中找出 \u003cstrong\u003e和为目标值\u003c/strong\u003e \u003cem\u003e\u003ccode\u003etarget\u003c/code\u003e\u003c/em\u003e 的那 \u003cstrong\u003e两个\u003c/strong\u003e 整数，并返回它们的数组下标。\u003c/p\u003e\n\u003cp\u003e你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。\u003c/p\u003e\n\u003cp\u003e你可以按任意顺序返回答案。\u003c/p\u003e\n\u003chr\u003e\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e示例 1：\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e输入：nums = [2,7,11,15], target = 9 输出：[0,1] 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e示例 2：\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e输入：nums = [3,2,4], target = 6 输出：[1,2]\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e示例 3：\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e输入：nums = [3,3], target = 6\n输出：[0,1]\u003c/p\u003e\n\u003chr\u003e\u003c/blockquote\u003e\n\u003ch2 id=\"哈希表\"\u003e哈希表\u003c/h2\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003efunc twoSum(nums []int, target int) []int {\n    for i := 0; i \u0026lt; len(nums); i++ {\n        for j := i + 1; j \u0026lt; len(nums); j++ {\n            if nums[i] + nums[j] == target {\n                return []int{i, j}  \n            }\n        }\n    }\n    return nil\n}\n\u003c/code\u003e\u003c/pre\u003e","title":"LeetCode 1.两数之和"},{"content":" 这周我认为过的不赖，无论是学习还是游戏，我能够记得我周一至周日每天的所作所为，不是一种浑浑噩噩的生活。这周可以说是恢复了一些学习的感觉，回顾了并发、学习了redis，添加了缓存，安装了docker，也和朋友一起玩了好久的瓦，这周过的真不赖☺️\n已完成事项 对并发进行了回顾和拓展，更加地理解了生产者-消费者模型，更加了解一些同步原语(Sync包)内除了waitgroup和mutex的一些内容，sync.Once，sync.Map和sync.Cond。同时了解一些并发模型，理发师问题，哲学家吃饭问题和读者写者问题。 对redis的5种类型string，list，hash，set和zset的各种操作进行了了解和实践 完成了对小项目的redis的连接，并在应用层对Get和用户登入添加了缓存化处理，对create，update和delete添加了缓存失效处理。 安装了docker，原本打算完成最基础的Goland对docker连接等基础的操作部署，不过由于Goland的内置docker版本太低，被新版的docker拒绝，先暂且搁置 下周计划 对小项目增加更多的redis部署，Redis连接失败时的降级策略等东西 不知道 ","permalink":"https://sheep44044.github.io/weekly/2025-11-24-weekly11/","summary":"\u003cblockquote\u003e\n\u003cp\u003e这周我认为过的不赖，无论是学习还是游戏，我能够记得我周一至周日每天的所作所为，不是一种浑浑噩噩的生活。这周可以说是恢复了一些学习的感觉，回顾了并发、学习了redis，添加了缓存，安装了docker，也和朋友一起玩了好久的瓦，这周过的真不赖☺️\u003c/p\u003e\u003c/blockquote\u003e\n\u003ch2 id=\"已完成事项\"\u003e已完成事项\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e对并发进行了回顾和拓展，更加地理解了生产者-消费者模型，更加了解一些同步原语(Sync包)内除了waitgroup和mutex的一些内容，sync.Once，sync.Map和sync.Cond。同时了解一些并发模型，理发师问题，哲学家吃饭问题和读者写者问题。\u003c/li\u003e\n\u003cli\u003e对redis的5种类型string，list，hash，set和zset的各种操作进行了了解和实践\u003c/li\u003e\n\u003cli\u003e完成了对小项目的redis的连接，并在应用层对Get和用户登入添加了缓存化处理，对create，update和delete添加了缓存失效处理。\u003c/li\u003e\n\u003cli\u003e安装了docker，原本打算完成最基础的Goland对docker连接等基础的操作部署，不过由于Goland的内置docker版本太低，被新版的docker拒绝，先暂且搁置\u003c/li\u003e\n\u003c/ol\u003e\n\u003chr\u003e\n\u003ch2 id=\"下周计划\"\u003e下周计划\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e对小项目增加更多的redis部署，Redis连接失败时的降级策略等东西\u003c/li\u003e\n\u003cli\u003e不知道\u003c/li\u003e\n\u003c/ol\u003e","title":"第十一周总结"},{"content":" 感恩🙏Goland，感恩🙏docker，如果没有你们的最新版本的冲突，我就不会学会去官网寻找答案，我不再是那个局限于AI的人了。\n真是服了，一个简单的goland连接docker功能，浪费了我这么多时间，\u0026ldquo;Status 400: client version 1.24 is too old. Minimum supported API version is 1.44, please upgrade your client to a newer version\u0026quot;这句话我真的是看吐了，什么docker which、docker version明明是1.52的最新版本，老是给我显示异常。\n最后，在官网docker插件这里发现大家都有这个问题，并且都是最近的，一周、两周前发表的评论。goland内置的docker的API版本太低了，被最新版的docker拒绝了，haha～\n给出的解决办法也是AI最不推荐的，把新版的docker删了，换成旧的版本，hh\n无语\n","permalink":"https://sheep44044.github.io/daily/2025-11-24-daily5/","summary":"\u003cblockquote\u003e\n\u003cp\u003e感恩🙏Goland，感恩🙏docker，如果没有你们的最新版本的冲突，我就不会学会去官网寻找答案，我不再是那个局限于AI的人了。\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e真是服了，一个简单的goland连接docker功能，浪费了我这么多时间，\u0026ldquo;Status 400: client version 1.24 is too old. Minimum supported API version is 1.44, please upgrade your client to a newer version\u0026quot;这句话我真的是看吐了，什么docker which、docker version明明是1.52的最新版本，老是给我显示异常。\u003c/p\u003e\n\u003cp\u003e最后，在官网docker插件这里发现大家都有这个问题，并且都是最近的，一周、两周前发表的评论。goland内置的docker的API版本太低了，被最新版的docker拒绝了，haha～\u003c/p\u003e\n\u003cp\u003e给出的解决办法也是AI最不推荐的，把新版的docker删了，换成旧的版本，hh\u003c/p\u003e\n\u003cp\u003e无语\u003c/p\u003e","title":"令人无语的goland和docker"},{"content":"1. 生产者-消费者模型 这是最基础、最常用、也是最实用的模型。\n有两个或多个生产者线程，它们生产数据（或任务）并放入一个共享的缓冲区。 有一个或多个消费者线程，它们从缓冲区中取出数据（或任务）并进行处理。 生产者和消费者之间通过这个缓冲区进行解耦。 核心挑战：\n缓冲区为空：消费者不能从空缓冲区取数据。 缓冲区已满：生产者不能向已满的缓冲区放数据。 竞态条件：对缓冲区的访问必须是互斥的，防止多个线程同时修改导致数据不一致。 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) type Task struct { Runnable func(workerId int) } func main() { // 一个负责任务分发的管道 ch := make(chan Task, 10) // 启动几个 worker 负责处理任务 for id := range 10 { go func(workerId int) { for t := range ch { t.Runnable(workerId) } }(id) } // 任务分发 for i := range 20 { j := i t1 := Task{ Runnable: func(workerId int) { fmt.Printf(\u0026#34;workerId%v：task%v做一件事情\\n\u0026#34;, workerId, j) }, } ch \u0026lt;- t1 } time.Sleep(1 * time.Second) close(ch) } 现实应用：\n消息队列（如Kafka, RabbitMQ）。 线程池任务调度。 Golang中的Channel，Java中的 BlockingQueue 其底层思想就是生产者-消费者模型。 2. 读者-写者问题 核心思想：在读多写少的问题中，对读写锁的使用，写锁类似于互斥锁，读锁类似于共享锁（能开多个）。\n读者只读取共享数据，不修改，写者会修改共享数据。允许多个读者同时读，但写者必须独占访问（即写时不能有读者或其他写者）。\n核心挑战：\n在保证数据一致性的前提下，最大限度地提高并发性（特别是对读者）。 可能导致写者饥饿：如果读者源源不断，写者可能永远无法获得访问权。 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;time\u0026#34; ) func main() { var ( data int rwMutex sync.RWMutex // 读写锁 wg sync.WaitGroup ) // 写者 wg.Add(1) go func() { defer wg.Done() for i := 0; i \u0026lt; 5; i++ { rwMutex.Lock() // 写锁 data = i fmt.Printf(\u0026#34;写入: %d\\n\u0026#34;, i) time.Sleep(time.Millisecond * 200) rwMutex.Unlock() time.Sleep(time.Millisecond * 100) } }() // 读者（多个） for i := 0; i \u0026lt; 3; i++ { wg.Add(1) go func(id int) { defer wg.Done() for j := 0; j \u0026lt; 5; j++ { rwMutex.RLock() // 读锁 fmt.Printf(\u0026#34;读者%d 读取: %d\\n\u0026#34;, id, data) time.Sleep(time.Millisecond * 50) rwMutex.RUnlock() time.Sleep(time.Millisecond * 100) } }(i) } wg.Wait() } 现实应用：\n数据库的并发控制。 文件系统、缓存的访问。 3. 哲学家就餐问题 核心思想：避免多个进程（或线程）竞争有限资源时的死锁问题，通过特定的策略(破坏循环)或限制并发度（筷子数量）等方法，解决死锁问题。\n五个哲学家围坐在一张圆桌旁，他们的一生只在做两件事：思考和吃饭。 桌上有五根筷子（不是五双），每两个哲学家之间有一根。 哲学家吃饭时需要同时拿起他左边和右边的筷子。 如果筷子在别人手里，他就必须等待。 核心挑战：\n死锁：如果所有哲学家同时感到饥饿，并同时拿起自己左边的筷子，那么所有人都会永远等待右边的筷子被释放，导致系统僵住。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;time\u0026#34; ) func main() { // 5根筷子（互斥锁） chopsticks := make([]sync.Mutex, 5) var wg sync.WaitGroup // 哲学家函数 philosopher := func(id int) { defer wg.Done() left := id right := (id + 1) % 5 // 避免死锁：编号为偶数的哲学家先拿左边，奇数先拿右边 for i := 0; i \u0026lt; 3; i++ { // 吃3次 if id%2 == 0 { chopsticks[left].Lock() chopsticks[right].Lock() } else { chopsticks[right].Lock() chopsticks[left].Lock() } // 拿到两根筷子，开始吃饭 fmt.Printf(\u0026#34;哲学家%d 正在吃饭...\\n\u0026#34;, id) time.Sleep(time.Millisecond * 100) // 放下筷子 chopsticks[left].Unlock() chopsticks[right].Unlock() // 思考 fmt.Printf(\u0026#34;哲学家%d 正在思考...\\n\u0026#34;, id) time.Sleep(time.Millisecond * 100) } } // 启动5个哲学家 for i := 0; i \u0026lt; 5; i++ { wg.Add(1) go philosopher(i) } wg.Wait() } 现实应用：\n任何需要获取多个互斥资源才能工作的场景，比如进程需要同时锁定多个数据库记录进行更新。\n4. 理发师问题 核心思想：模拟有容量限制的服务系统，通过空结构体(似乎叫信号量)来实现请求者与服务者的同步，并实现超容量时的拒绝和服务者的空闲/工作状态转换。\n一个理发店有一个理发师（服务线程）、一把理发椅（临界资源）和N把供顾客等待的椅子（等待队列）。 如果没有顾客，理发师就在理发椅上睡觉。 顾客到来时，如果理发师在睡觉，就叫醒他理发。 如果理发师在忙，顾客就坐在等待椅上等待。 如果等待椅也坐满了，顾客就会离开。 核心挑战：\n协调理发师（服务者）和顾客（请求者）的睡眠与唤醒。 管理有限的等待队列。 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;math/rand\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;time\u0026#34; ) func main() { // 理发店参数 const ( waitingChairs = 3 // 等待椅数量 totalCustomers = 10 // 总顾客数 ) var ( waitingRoom = make(chan struct{}, waitingChairs) // 等待室（缓冲channel） wg sync.WaitGroup barberReady = make(chan struct{}, 1) // 理发师就绪信号 ) // 理发师 wg.Add(1) go func() { defer wg.Done() for { select { case \u0026lt;-waitingRoom: // 有顾客，开始理发 barberReady \u0026lt;- struct{}{} // 理发师准备就绪 fmt.Println(\u0026#34;理发师正在理发...\u0026#34;) time.Sleep(time.Millisecond * 200) // 理发时间 fmt.Println(\u0026#34;理发完成！\u0026#34;) default: // 没有顾客，睡觉 fmt.Println(\u0026#34;理发师在睡觉...\u0026#34;) time.Sleep(time.Millisecond * 500) } } }() // 顾客 for i := 0; i \u0026lt; totalCustomers; i++ { wg.Add(1) go func(id int) { defer wg.Done() time.Sleep(time.Millisecond * time.Duration(rand.Intn(300))) select { case waitingRoom \u0026lt;- struct{}{}: // 成功进入等待室 fmt.Printf(\u0026#34;顾客%d 在等待理发\\n\u0026#34;, id) \u0026lt;-barberReady // 等待理发师就绪 fmt.Printf(\u0026#34;顾客%d 正在理发\\n\u0026#34;, id) default: // 等待室满了，离开 fmt.Printf(\u0026#34;顾客%d 看到等待室满了，离开了\\n\u0026#34;, id) } }(i) } // 等待所有顾客完成 time.Sleep(time.Second * 3) fmt.Println(\u0026#34;营业结束\u0026#34;) } 现实应用：\n线程池或服务器模型。例如，一个Web服务器有固定数量的工作线程（理发师）和一个最大连接队列（等待椅）。当新请求到达时，如果有空闲线程则立即处理，否则进入队列等待，如果队列也满了，则返回“服务器繁忙”错误。\n","permalink":"https://sheep44044.github.io/posts/2025-11-18-%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B/","summary":"\u003ch2 id=\"1-生产者-消费者模型\"\u003e1. 生产者-消费者模型\u003c/h2\u003e\n\u003cp\u003e这是最基础、最常用、也是最实用的模型。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e有两个或多个\u003cstrong\u003e生产者\u003c/strong\u003e线程，它们生产数据（或任务）并放入一个共享的\u003cstrong\u003e缓冲区\u003c/strong\u003e。\u003c/li\u003e\n\u003cli\u003e有一个或多个\u003cstrong\u003e消费者\u003c/strong\u003e线程，它们从缓冲区中取出数据（或任务）并进行处理。\u003c/li\u003e\n\u003cli\u003e生产者和消费者之间通过这个缓冲区进行\u003cstrong\u003e解耦\u003c/strong\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e核心挑战\u003c/strong\u003e：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e缓冲区为空\u003c/strong\u003e：消费者不能从空缓冲区取数据。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e缓冲区已满\u003c/strong\u003e：生产者不能向已满的缓冲区放数据。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e竞态条件\u003c/strong\u003e：对缓冲区的访问必须是互斥的，防止多个线程同时修改导致数据不一致。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003epackage main\n\nimport (\n    \u0026#34;fmt\u0026#34;\n    \u0026#34;time\u0026#34;\n)\n\ntype Task struct {\n    Runnable func(workerId int)\n}\n\nfunc main() {\n    // 一个负责任务分发的管道\n    ch := make(chan Task, 10)\n\n    // 启动几个 worker 负责处理任务\n    for id := range 10 {\n        go func(workerId int) {\n            for t := range ch {\n                t.Runnable(workerId)\n            }\n        }(id)\n    }\n\n    // 任务分发\n    for i := range 20 {\n\t    j := i\n        t1 := Task{\n            Runnable: func(workerId int) {\n                fmt.Printf(\u0026#34;workerId%v：task%v做一件事情\\n\u0026#34;, workerId, j)\n            },\n        }\n        ch \u0026lt;- t1\n    }\n    time.Sleep(1 * time.Second)\n    close(ch)\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003e现实应用\u003c/strong\u003e：\u003c/p\u003e","title":"一些并发的模型"},{"content":"并发 什么是并发？我的理解是并发是关于如何让一个系统在面对多个任务时，既能高效地利用资源，又能正确地协调它们之间的交互。在《戴森球计划》等游戏运行时，CPU满载运行时渲染的蓝色洪流，我认为是对并发/并行最完美的具象化呈现。\n先说进程。 进程是一个正在运行的程序实例，Chrome浏览器和Word文档，它们就是两个不同的进程。操作系统会为每个进程分配彼此隔离的用户空间，并把它们交给 CPU 调度执行。一个应用可以只开一个进程，也可以开很多个，这取决于应用自身；对操作系统来说，进程之间没有啥区别，它只负责把要跑的活儿交给 CPU。\n那一颗 CPU 怎么“同时”跑这么多东西？ 关键在于“时间片”。单个 CPU 核心同一时刻只能执行一个任务，但操作系统会把时间切成很细的片段，轮流把这些时间片分给不同的可运行实体。每个时间片到了就切换到下一个，如此快速轮转，让我们主观上感觉“所有程序都在同时跑”。这就是并发，宏观上的并行，微观上的交替。\n再说线程。线程是操作系统调度的最小单位，线程通常对应一个功能。一个进程至少包含一个线程；所谓“调度进程”本质上是在调度进程里的线程。同一进程中的线程共享进程的资源，但各自拥有独立的栈（栈主要是负责存局部变量和函数调用栈等数据的）。\n线程大致分两类：\n内核级线程：创建、销毁、调度与上下文切换由内核完成，需要系统调用，开销相对更高。 用户级线程(协程)：在线程库/运行时于用户态完成调度与切换，通常只在必要时与少量内核线程关联，因而切换开销更小。 goroutine 就是一种用户级线程 它由 Go 运行时在用户态调度，创建成本低、切换轻量，还配有按需增长的栈。运行时采用 M:N 调度（后面可以了解一下 GMP 模型），把大量 goroutine 映射到少量内核线程上，从而在保持高并发的同时控制系统调用与上下文切换的成本。\nGoroutine Go语言中使用goroutine非常简单，只需要在调用函数的时候在前面加上go关键字，就可以为一个函数创建一个goroutine。一个goroutine必定对应一个函数，可以创建多个goroutine去执行相同的函数。\n我们想要实现一下用 10 个协程去累加一个数字，每个协程将这个变量自增 10w 次，我们期望得到 100w 的结果\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { sum := 0 for range 10 { go func() { for range 100000 { sum += 1 } }() } time.Sleep(1 * time.Second) fmt.Println(sum) } 结果呢？\nroot@RINAI-SWORD:/project/lanshan/count# go run ./ 569738 root@RINAI-SWORD:/project/lanshan/count# go run ./ 503786 root@RINAI-SWORD:/project/lanshan/count# go run ./ 595125 得到是不确定的数字，可能有人觉得奇怪，但是在现实中，这才是符合预期的，你如果把数值调小，让多个线程累加到 100 或者 1000，你的结果可能正是你期望的，但是仅仅是因为样本数量太少而没有引发多线程出现的问题。\n那么为什么会出现这种结果？\n这涉及到我们 cpu 的工作原理，我们的一条自增 ++ 代码，在 cpu 层面并不是原子执行的，实际上，一个简单的自增在计算机层面会是这样的顺序：\n1. cpu 从指定内存读取 sum 的值 2. cpu 将 sum + 1。 3. cpu 将 sum 写回指定内存。 大概是这三个步骤，那么在多线程场景下思考，只要在 1 -\u0026gt; 2 的间隙发生线程切换，这里线程切换会将当前线程中的某些上下文数据保存下来到内存中，等到切换回线程1的时候就会从内存中恢复这些数据到 cpu 中，在另一个线程中执行了 sum + 1，就会导致我们当前 cpu 读取的数值是旧的，比如：\n线程1：cpu 读取到 sum = 10。 线程2：cpu 读取到 sum = 10。 线程2：cpu 将 sum + 1。 线程2：cpu 回写 sum，此时 sum = 11。 线程1：cpu 根据读取到的 sum + 1。 线程1：cpu 回写 sum，此时 sum = 11. 由此可见，多线程虽然利用多核的优势，但是也给我们带来了一些麻烦。因此，我们需要同步原语，以消除这种不确定性，在并发环境中强制实现“顺序”和“互斥”\n原子性和原子操作 原子性的核心目标是保证数据在并发访问下的一致性。\n在多线程/多核环境中，操作系统会随时在不同的线程之间进行切换，如果一个非原子操作执行到一半被中断，而另一个线程又来读取或修改相同的数据，结果将是不可预测的。\n通常是原子的（在主流32/64位CPU上）：\n读取或写入一个对齐的、原生数据类型（如在Go中，int32、int64、bool等变量的单次读或写）通常是原子的。这意味着你不会读到半个写操作的结果。 通常不是原子的（需要额外保护）：\n任何需要多个步骤的操作： ​\t对结构体、切片、映射等复杂数据结构的修改。\n​\t在32位系统上对64位变量的读写（如 int64），可能需要两条指令来完成。\n**原子操作：**Go中 sync/atomic 包，封装了底层的硬件原子指令，提供了如 atomic.AddInt32、atomic.LoadPointer、atomic.CompareAndSwapUint64 等函数。\nChannel \u0026ldquo;不要通过共享内存来通信，而要通过通信来共享内存\u0026quot;，这句话便是 Go 语言的并发哲学，什么意思？就是说，如果两个 goroutine 希望共享一个变量，不应该通过一个外部的全局变量来进行加锁读写，而是应该通过 channel 将 goroutine A 中的变量传递给 goroutine B。\n下面是一个任务调度器：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) type Task struct { // 函数也可以是结构体的成员 Runnable func(workerId int) } func main() { // 一个负责任务分发的管道 ch := make(chan Task, 10) // 启动几个 worker 负责处理任务 for id := range 10 { go func(workerId int) { for t := range ch { t.Runnable(workerId) } }(id) } // 任务分发 for i := range 20 { j := i t1 := Task{ Runnable: func(workerId int) { fmt.Printf(\u0026#34;workerId%v：task%v做一件事情\\n\u0026#34;, workerId, j) }, } ch \u0026lt;- t1 } time.Sleep(1 * time.Second) close(ch) } select 关键字 用于处理多个通道的读写操作，类似于switch，每个case都是通道操作，但是最终只会执行一个(如果多个通道同时接收到数值，会随机选择一个进行接收)。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { tick := time.Tick(100 * time.Millisecond) boom := time.After(500 * time.Millisecond) for { select { case \u0026lt;-tick: fmt.Println(\u0026#34;tick.\u0026#34;) case \u0026lt;-boom: fmt.Println(\u0026#34;BOOM!\u0026#34;) return default: fmt.Println(\u0026#34; .\u0026#34;) time.Sleep(50 * time.Millisecond) } } } 同步原语(Sync包) 1 .WaitGroup 它提供了一种简单、同步的方式，让一个 Goroutine（通常是主 Goroutine）能够阻塞，直到其他多个 Goroutine 都完成它们的工作。它只有三个方法Add(delta int)、Done()和Wait()，功能正如字面意思一样。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; ) func main() { wg := sync.WaitGroup{} for range 10 { // wg.Add 计数器+1，代表添加一个执行任务 wg.Add(1) go func() { fmt.Println(1) // wg.Done() 计数器-1，代表执行完成 wg.Done() }() } // 等待 Add 的任务全部 Done wg.Wait() } 2 .Mutex互斥锁 对于同一把互斥锁：同一时间只能有一个协程获得锁，当锁被持有时，其他协程尝试加锁会被阻塞，直到锁被释放。\nvar mu sync.Mutex var counter int func increment() { mu.Lock() // 加锁 defer mu.Unlock() // 函数返回时解锁 counter++ } 除了 sync.Mutex 还有一种另一种锁 sync.RWmutex 也就是读写锁，因为在只有并发读，没有并发写的时候，再加锁并没有什么用，因为并发读始终是安全的，因此读写锁就是针对于互斥锁的一个优化，在读多写少的场景下我们可以选择读写锁来替代互斥锁。\n3.sync.Once 程序运行时，懒加载初始化常用（其实平时也不咋用这个），保证了整个生命周期，一个 sync.Once 对象仅会执行一次 Do 方法，多余的都会跳过。\n比如：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; ) func main() { init := sync.Once{} num := 0 for range 10 { init.Do(func() { num ++ }) } fmt.Println(num) } 结果为 1，无需多言。\n4.sync.Map 众所不周知，我们 go 中原生的 map 并不是并发安全的，在并发读写的情况下会 panic，导致程序崩溃，于是 sync 标准库推出了 sync.Map ，这是一个并发安全的 map，严格意义来说，我们直接在原生 map 的基础上加互斥锁或者读写锁也能够解决问题，但是 sync.Map 是做了一定基础的优化的，go 1.24 之前的版本和之后的版本有不同的实现方式，感兴趣可以去了解一下。总之，有了它，我们就不需要为 map 维护一个互斥锁了。\n5. sync.Cond 它可以实现一种信号通知的功能\npackage main import ( \u0026#34;sync\u0026#34; \u0026#34;time\u0026#34; ) func main() { l := sync.Mutex{} c := sync.NewCond(\u0026amp;l) go func() { // 调用 wait 前需要先加锁 c.L.Lock() c.Wait() println(\u0026#34;Hello, world!\u0026#34;) // 调用 wait 后需要解锁 c.L.Unlock() }() time.Sleep(time.Second) println(\u0026#34;唤醒\u0026#34;) // Signal 方法唤醒等待的 goroutine c.Signal() time.Sleep(time.Second) println(\u0026#34;end\u0026#34;) } 剩下的不常用。\n参考链接：https://draven.co/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/\nContext 上下文 context 可以在函数传播链中用于存储一些 kv 键值对信息用于下游获取，也可以在并发控制中发挥作用，比如我们可以为这个函数调用设计一个超时时间，我们的 context 就可以通过这个超时时间来取消这个函数调用链，除了超时控制，我们还可以手动地去 cancel 这个上下文，取消这次调用，但是需要注意的是，你即便取消了这个 context,已经执行的代码并不能撤回，谨慎设置超时时间。 例子：\npackage main import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func doSomething(ctx context.Context) { for { select { case \u0026lt;-ctx.Done(): fmt.Println(\u0026#34;doSomething stopped:\u0026#34;, ctx.Err()) return // 退出 goroutine default: fmt.Println(\u0026#34;hello\u0026#34;) time.Sleep(time.Second) } } } func main() { ctx := context.Background() ctx, cancel := context.WithTimeout(ctx, 2*time.Second) defer cancel() doSomething(ctx) } 详细讲解 https://draven.co/golang/docs/part3-runtime/ch06-concurrency/golang-context/\n","permalink":"https://sheep44044.github.io/posts/2025-11-18-%E5%B9%B6%E5%8F%91/","summary":"\u003ch2 id=\"并发\"\u003e并发\u003c/h2\u003e\n\u003cp\u003e什么是并发？我的理解是\u003cstrong\u003e并发是关于如何让一个系统在面对多个任务时，既能高效地利用资源，又能正确地协调它们之间的交互\u003c/strong\u003e。在《戴森球计划》等游戏运行时，CPU满载运行时渲染的蓝色洪流，我认为是对并发/并行最完美的具象化呈现。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e先说进程。\u003c/strong\u003e 进程是一个正在运行的程序实例，Chrome浏览器和Word文档，它们就是两个不同的进程。操作系统会为每个进程分配彼此隔离的用户空间，并把它们交给 CPU 调度执行。一个应用可以只开一个进程，也可以开很多个，这取决于应用自身；对操作系统来说，进程之间没有啥区别，它只负责把要跑的活儿交给 CPU。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e那一颗 CPU 怎么“同时”跑这么多东西？\u003c/strong\u003e 关键在于“时间片”。单个 CPU 核心同一时刻只能执行一个任务，但操作系统会把时间切成很细的片段，轮流把这些时间片分给不同的可运行实体。每个时间片到了就切换到下一个，如此快速轮转，让我们主观上感觉“所有程序都在同时跑”。\u003cstrong\u003e这就是并发\u003c/strong\u003e，宏观上的并行，微观上的交替。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e再说线程。线程是操作系统调度的最小单位\u003c/strong\u003e，线程通常对应一个功能。一个进程至少包含一个线程；所谓“调度进程”本质上是在\u003cstrong\u003e调度进程里的线程\u003c/strong\u003e。同一进程中的线程共享进程的资源，但各自拥有独立的栈（栈主要是负责存局部变量和函数调用栈等数据的）。\u003c/p\u003e\n\u003cp\u003e线程大致分两类：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e内核级线程\u003c/strong\u003e：创建、销毁、调度与上下文切换由内核完成，需要系统调用，开销相对更高。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e用户级线程(协程)\u003c/strong\u003e：在线程库/运行时于用户态完成调度与切换，通常只在必要时与少量内核线程关联，因而切换开销更小。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003egoroutine 就是一种用户级线程\u003c/strong\u003e 它由 Go 运行时在用户态调度，创建成本低、切换轻量，还配有按需增长的栈。运行时采用 M:N 调度（后面可以了解一下 \u003cstrong\u003eGMP 模型\u003c/strong\u003e），把大量 goroutine 映射到少量内核线程上，从而在保持高并发的同时控制系统调用与上下文切换的成本。\u003c/p\u003e\n\u003ch2 id=\"goroutine\"\u003eGoroutine\u003c/h2\u003e\n\u003cp\u003eGo语言中使用goroutine非常简单，只需要在调用函数的时候在前面加上go关键字，就可以为一个函数创建一个goroutine。一个goroutine必定对应一个函数，可以创建多个goroutine去执行相同的函数。\u003c/p\u003e\n\u003cp\u003e我们想要实现一下用 10 个协程去累加一个数字，每个协程将这个变量自增 10w 次，我们期望得到 100w 的结果\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003epackage main\n\nimport (\n    \u0026#34;fmt\u0026#34;\n    \u0026#34;time\u0026#34;\n)\n\nfunc main() {\n    sum := 0\n    for range 10 {\n        go func() {\n            for range 100000 {\n                sum += 1\n            }\n        }()\n    }\n    time.Sleep(1 * time.Second)\n    fmt.Println(sum)\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e结果呢？\u003c/p\u003e","title":"并发"},{"content":" 这周就是准备和完成了这次概率论的期中考，其次主要是进行第一次的pr，虽然只是简单地修改了格式错误，但是看到自己的头像出现在contributors这一栏中还是很有成就感的😍。现在已经是第十一周了，距离期末考就一个半月的时间了，在这期间继续努力吧。\n已完成事项 完成概率论期中考 进行了一次开源尝试，提交了一次pr 下周计划 学习并部署redis 不知道 ","permalink":"https://sheep44044.github.io/weekly/2025-11-17-weekly10/","summary":"\u003cblockquote\u003e\n\u003cp\u003e这周就是准备和完成了这次概率论的期中考，其次主要是进行第一次的pr，虽然只是简单地修改了格式错误，但是看到自己的头像出现在contributors这一栏中还是很有成就感的😍。现在已经是第十一周了，距离期末考就一个半月的时间了，在这期间继续努力吧。\u003c/p\u003e\u003c/blockquote\u003e\n\u003ch2 id=\"已完成事项\"\u003e已完成事项\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e完成概率论期中考\u003c/li\u003e\n\u003cli\u003e进行了一次开源尝试，提交了一次pr\u003c/li\u003e\n\u003c/ol\u003e\n\u003chr\u003e\n\u003ch2 id=\"下周计划\"\u003e下周计划\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e学习并部署redis\u003c/li\u003e\n\u003cli\u003e不知道\u003c/li\u003e\n\u003c/ol\u003e","title":"第十周总结"},{"content":" 这一周，我在爽玩鸭科夫的基础上，算是顺利的完成了上周的学习了bcrypt包的密码加密，并完成了用户的登陆和注册(不过用户登陆使用的jwt内容有点忘记，下周考完试在回顾一下)。虽然有考试的原因，但感觉最近几周有点懈怠了，周报都没什么好写（想当初我左学gin，右学gorm，还有时间学习大物，真是物是人非啊🫠）\n已完成事项 学习bcrypt包的密码加密 用bcrypt和jwt完成了用户的登陆和注册 稍微看了一些redis 下周计划 复习概率论✅ 还有时间的话，学习redis并部署 ","permalink":"https://sheep44044.github.io/weekly/2025-11-10-weekly9/","summary":"\u003cblockquote\u003e\n\u003cp\u003e这一周，我在爽玩鸭科夫的基础上，算是顺利的完成了上周的学习了bcrypt包的密码加密，并完成了用户的登陆和注册(不过用户登陆使用的jwt内容有点忘记，下周考完试在回顾一下)。虽然有考试的原因，但感觉最近几周有点懈怠了，周报都没什么好写（想当初我左学gin，右学gorm，还有时间学习大物，真是物是人非啊🫠）\u003c/p\u003e\u003c/blockquote\u003e\n\u003ch2 id=\"已完成事项\"\u003e已完成事项\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e学习bcrypt包的密码加密\u003c/li\u003e\n\u003cli\u003e用bcrypt和jwt完成了用户的登陆和注册\u003c/li\u003e\n\u003cli\u003e稍微看了一些redis\u003c/li\u003e\n\u003c/ol\u003e\n\u003chr\u003e\n\u003ch2 id=\"下周计划\"\u003e下周计划\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e复习概率论✅\u003c/li\u003e\n\u003cli\u003e还有时间的话，学习redis并部署\u003c/li\u003e\n\u003c/ol\u003e","title":"第九周总结"},{"content":"bcrypt 是一种结合了盐值机制的自适应哈希函数。与普通哈希算法的根本区别在于，bcrypt 在设计上内置了盐值的使用，从而显著提升了密码存储的安全性。\n普通哈希算法存在一个关键缺陷：对于相同的输入，始终产生相同的输出。这意味着如果多个用户使用相同密码（例如“123456”），其哈希值也会完全相同，系统因此容易受到彩虹表攻击。\n彩虹表攻击：彩虹表就是一张升级版的储存常见明文密码和哈希值的表。它通过链式结构和规约函数解决了存储空间的问题，平衡了空间和时间。\n盐（Salt） 就是为了解决这个问题而生的。\n定义：盐是一段随机生成的、足够长的字符串。 工作方式：在哈希密码之前，系统会先为每个用户生成一个独一无二的盐，然后把这个盐拼接在用户的密码后面，再对**“密码+盐”** 这个组合进行哈希。 存储：最终，系统将哈希结果和盐值本身一起存储到数据库中 由于每个用户拥有独特的盐值，即使密码相同，最终得到的哈希结果也会完全不同。这意味着攻击者无法使用同一张彩虹表破解所有用户密码，而必须为每个盐值单独建立破解表，这使得攻击成本急剧上升，在实际中几乎不可行。\n此外，bcrypt 被刻意设计为计算缓慢且内存密集，这种“故意低效”的设计大幅增加了暴力破解和彩虹表构建所需的时间和资源开销。\n总结来说，bcrypt = 故意缓慢的哈希算法 + 自动强盐机制 + 可配置的计算成本。\nbcrypt的使用在Golang中则是比较简单，具体可以见bcrypt文档\n下面简单说一下：\n1.生成密码哈希\nfunc GenerateFromPassword(password []byte, cost int) ([]byte, error) 2.验证密码\nfunc CompareHashAndPassword(hashedPassword, password []byte) error 3.获取哈希成本\nfunc Cost(hashedPassword []byte) (int, error) tips：bcrypt 最多处理 72 字节的密码\n","permalink":"https://sheep44044.github.io/posts/2025-11-05-bcrypt/","summary":"\u003cp\u003e\u003cstrong\u003ebcrypt\u003c/strong\u003e 是一种结合了盐值机制的自适应哈希函数。与普通哈希算法的根本区别在于，bcrypt 在设计上内置了盐值的使用，从而显著提升了密码存储的安全性。\u003c/p\u003e\n\u003cp\u003e普通哈希算法存在一个关键缺陷：对于相同的输入，始终产生相同的输出。这意味着如果多个用户使用相同密码（例如“123456”），其哈希值也会完全相同，系统因此容易受到彩虹表攻击。\u003c/p\u003e\n\u003cp\u003e彩虹表攻击：彩虹表就是一张升级版的储存常见明文密码和哈希值的表。它通过链式结构和规约函数解决了存储空间的问题，平衡了空间和时间。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e盐（Salt）\u003c/strong\u003e 就是为了解决这个问题而生的。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e定义\u003c/strong\u003e：盐是一段随机生成的、足够长的字符串。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e工作方式\u003c/strong\u003e：在哈希密码之前，系统会先为每个用户生成一个独一无二的盐，然后把这个盐拼接在用户的密码后面，再对**“密码+盐”** 这个组合进行哈希。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e存储\u003c/strong\u003e：最终，系统将\u003cstrong\u003e哈希结果\u003c/strong\u003e和\u003cstrong\u003e盐值本身\u003c/strong\u003e一起存储到数据库中\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e由于每个用户拥有独特的盐值，即使密码相同，最终得到的哈希结果也会完全不同。这意味着攻击者无法使用同一张彩虹表破解所有用户密码，而必须为每个盐值单独建立破解表，这使得攻击成本急剧上升，在实际中几乎不可行。\u003c/p\u003e\n\u003cp\u003e此外，bcrypt 被刻意设计为计算缓慢且内存密集，这种“故意低效”的设计大幅增加了暴力破解和彩虹表构建所需的时间和资源开销。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e总结来说，bcrypt = 故意缓慢的哈希算法 + 自动强盐机制 + 可配置的计算成本\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003ebcrypt的使用在Golang中则是比较简单，具体可以见\u003ca href=\"https://pkg.go.dev/golang.org/x/crypto/bcrypt\"\u003ebcrypt文档\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e下面简单说一下：\u003c/p\u003e\n\u003cp\u003e1.生成密码哈希\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-go\" data-lang=\"go\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003efunc\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eGenerateFromPassword\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003epassword\u003c/span\u003e []\u003cspan style=\"color:#66d9ef\"\u003ebyte\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003ecost\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e) ([]\u003cspan style=\"color:#66d9ef\"\u003ebyte\u003c/span\u003e, \u003cspan style=\"color:#66d9ef\"\u003eerror\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e2.验证密码\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-go\" data-lang=\"go\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003efunc\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eCompareHashAndPassword\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003ehashedPassword\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003epassword\u003c/span\u003e []\u003cspan style=\"color:#66d9ef\"\u003ebyte\u003c/span\u003e) \u003cspan style=\"color:#66d9ef\"\u003eerror\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e3.获取哈希成本\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-go\" data-lang=\"go\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003efunc\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eCost\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003ehashedPassword\u003c/span\u003e []\u003cspan style=\"color:#66d9ef\"\u003ebyte\u003c/span\u003e) (\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e, \u003cspan style=\"color:#66d9ef\"\u003eerror\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003etips：bcrypt 最多处理 72 字节的密码\u003c/p\u003e","title":"Bcrypt和盐"},{"content":" 这一周就是哼哧哼哧地复习大学物理和离散，考完期中考，并度过了一个很爽的周末，在鸭科夫里大搜特搜，大赚特赚。在瓦里又上了一段。喔吼～不过也确实没什么好说的，这周就是这么简单。\n已完成事项 考完离散 考完大物 下周计划 看一下之前的代码（有点不记得了）✅ 完成用户的登陆和注册，学习使用bcrypt加密（上周的计划）✅ ","permalink":"https://sheep44044.github.io/weekly/2025-11-03-weekly8/","summary":"\u003cblockquote\u003e\n\u003cp\u003e这一周就是哼哧哼哧地复习大学物理和离散，考完期中考，并度过了一个很爽的周末，在鸭科夫里大搜特搜，大赚特赚。在瓦里又上了一段。喔吼～不过也确实没什么好说的，这周就是这么简单。\u003c/p\u003e\u003c/blockquote\u003e\n\u003ch2 id=\"已完成事项\"\u003e已完成事项\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e考完离散\u003c/li\u003e\n\u003cli\u003e考完大物\u003c/li\u003e\n\u003c/ol\u003e\n\u003chr\u003e\n\u003ch2 id=\"下周计划\"\u003e下周计划\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e看一下之前的代码（有点不记得了）✅\u003c/li\u003e\n\u003cli\u003e完成用户的登陆和注册，学习使用bcrypt加密（上周的计划）✅\u003c/li\u003e\n\u003c/ol\u003e","title":"第八周总结"},{"content":" 这一周我感觉过得挺失败的☹️，虽然顺利完成了数据结构的考试，也在项目上更进一步（虽然依靠了AI的帮助），但是感觉效率不是很高，有点焦虑和倦怠。正如我在之前吐槽到别人真的太强了，我还在吭哧吭哧学习。不过这里就不多焦虑了。下周有大学物理和离散结构的考试，主要是复习，有机会的话理解回顾一下代码（有些ai生成的没理解）和学习一下bcrypt加密。\n已完成事项 成功完成数据结构考试 Viper来进行配置管理 实现jwt的鉴权 下周计划 复习大学物理✅ 复习离散结构✅ 完成用户的登陆和注册，学习使用bcrypt加密 ","permalink":"https://sheep44044.github.io/weekly/2025-10-27-weekly7/","summary":"\u003cblockquote\u003e\n\u003cp\u003e这一周我感觉过得挺失败的☹️，虽然顺利完成了数据结构的考试，也在项目上更进一步（虽然依靠了AI的帮助），但是感觉效率不是很高，有点焦虑和倦怠。正如我在之前吐槽到别人真的太强了，我还在吭哧吭哧学习。不过这里就不多焦虑了。下周有大学物理和离散结构的考试，主要是复习，有机会的话理解回顾一下代码（有些ai生成的没理解）和学习一下bcrypt加密。\u003c/p\u003e\u003c/blockquote\u003e\n\u003ch2 id=\"已完成事项\"\u003e已完成事项\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e成功完成数据结构考试\u003c/li\u003e\n\u003cli\u003eViper来进行配置管理\u003c/li\u003e\n\u003cli\u003e实现jwt的鉴权\u003c/li\u003e\n\u003c/ol\u003e\n\u003chr\u003e\n\u003ch2 id=\"下周计划\"\u003e下周计划\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e复习大学物理✅\u003c/li\u003e\n\u003cli\u003e复习离散结构✅\u003c/li\u003e\n\u003cli\u003e完成用户的登陆和注册，学习使用bcrypt加密\u003c/li\u003e\n\u003c/ol\u003e","title":"第七周总结"},{"content":"可能是因为我渴望完美，却又深感自己的不足，所以我发现自己是个很喜欢听鸡汤的人——希望用那些励志的话语同时麻痹和激励自己。记得曾听过这样一句话：“人们总是高估短时间内的努力，又低估长时间的努力。”\n最近看到一位技术大神在他的博客中写道：“在准备一个能帮我找到第一段实习的项目，再配一个工作室的小程序可能差不多？之后就得复习八股文准备面试了。但感觉在此之前，还有好多东西没学，像最近流行的agent技术，还有一直想学的k8s也只是浅尝辄止。或许，还是我太着急了吧。”\n我不知道他的焦虑是否真实，但这些话确实引发了我的焦虑。同样处于大二上学期，当别人已经掌握了那么多技术时，我还在学习如何使用viper和zap这样基础的工具来完成一个小项目。诚然，别人从大一甚至更早就开始学习Golang，而我真正学习这门语言，不过一个半月而已。\n但现实不像游戏存档，它不会看你单位时间内的成长速度，只会在同一时间轴上比较每个人的成就，然后毫不留情地展示出我的弱小。\n最近因杨振宁先生逝世，我在知乎上了解到了他的老师费米的故事。费米曾在一门课程的导论中写道：\n加州理工是座优秀的大学，它必须不断筛选学生。能够来到这里的学生无不是优秀的。但在加州理工有这么一个现实问题：总有一半的同学会位于后50%。\n对于这个问题，有人觉得可笑，但这确实是个需要正视的问题。费米认为，这里的学生最大的挑战其实是心理问题。\n如果有位排名后20%的学生来找他，说自己无论如何都学不会这门课，不知该怎么办。费米会这样回答：\n“你能够来到加州理工，说明你已经从几十上百名同辈中脱颖而出。现在你在这里排名后20%，你可以选择接受这个现实，这无可厚非。\n或者，你可以不理性地看待现状——虽然你位于后20%，但在这个群体中你可能是前几名。避免让现状影响你的心态，同时理性地继续努力。最终，你或许会成为前面的几名。”\n就像这个故事所说，虽然我身在一所双非院校，无法与加州理工相提并论，但我同样可以用这种“不理性”来暂时麻痹自己：牛客上确实有人在几个月内抱佛脚成功，小黑盒上类似的例子更是数不胜数……\n但我知道，焦虑不会就此消失。毕竟我已经大二了——大二的同辈有一年的学习积累，大一的新生又潜力无限。时间，终究不是站在我这边的\u0026hellip;\n我不是《凡人修仙传》里的韩立，我没有小绿瓶，我也没有什么机缘，我只是一名普通的邮兵。我只能继续学习啊\u0026hellip;也许等未来我成为了一名架构师，维护着上亿人使用的app时，也会焦虑吧\u0026hellip;\n不过现在的我身处迷雾之中，而未来又在何方呢？\n焦虑啊，焦虑啊\u0026hellip;\n也许成长就是这样——一边焦虑，一边向前\u0026hellip;\n写于 2025年10月26日 晚\n","permalink":"https://sheep44044.github.io/daily/2025-10-26-daily4/","summary":"\u003cp\u003e可能是因为我渴望完美，却又深感自己的不足，所以我发现自己是个很喜欢听鸡汤的人——希望用那些励志的话语同时麻痹和激励自己。记得曾听过这样一句话：“人们总是高估短时间内的努力，又低估长时间的努力。”\u003c/p\u003e\n\u003cp\u003e最近看到一位技术大神在他的博客中写道：“在准备一个能帮我找到第一段实习的项目，再配一个工作室的小程序可能差不多？之后就得复习八股文准备面试了。但感觉在此之前，还有好多东西没学，像最近流行的agent技术，还有一直想学的k8s也只是浅尝辄止。或许，还是我太着急了吧。”\u003c/p\u003e\n\u003cp\u003e我不知道他的焦虑是否真实，但这些话确实引发了我的焦虑。同样处于大二上学期，当别人已经掌握了那么多技术时，我还在学习如何使用viper和zap这样基础的工具来完成一个小项目。诚然，别人从大一甚至更早就开始学习Golang，而我真正学习这门语言，不过一个半月而已。\u003c/p\u003e\n\u003cp\u003e但现实不像游戏存档，它不会看你单位时间内的成长速度，只会在同一时间轴上比较每个人的成就，然后毫不留情地展示出我的弱小。\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e最近因杨振宁先生逝世，我在知乎上了解到了他的老师费米的故事。费米曾在一门课程的导论中写道：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e加州理工是座优秀的大学，它必须不断筛选学生。能够来到这里的学生无不是优秀的。但在加州理工有这么一个现实问题：\u003cstrong\u003e总有一半的同学会位于后50%\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e对于这个问题，有人觉得可笑，但这确实是个需要正视的问题。费米认为，这里的学生最大的挑战其实是心理问题。\u003c/p\u003e\n\u003cp\u003e如果有位排名后20%的学生来找他，说自己无论如何都学不会这门课，不知该怎么办。费米会这样回答：\u003c/p\u003e\n\u003cp\u003e“你能够来到加州理工，说明你已经从几十上百名同辈中脱颖而出。现在你在这里排名后20%，你可以选择接受这个现实，这无可厚非。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e或者，你可以不理性地看待现状\u003c/strong\u003e——虽然你位于后20%，但在这个群体中你可能是前几名。避免让现状影响你的心态，同时理性地继续努力。最终，你或许会成为前面的几名。”\u003c/p\u003e\u003c/blockquote\u003e\n\u003chr\u003e\n\u003cp\u003e就像这个故事所说，虽然我身在一所双非院校，无法与加州理工相提并论，但我同样可以用这种“不理性”来暂时麻痹自己：牛客上确实有人在几个月内抱佛脚成功，小黑盒上类似的例子更是数不胜数……\u003c/p\u003e\n\u003cp\u003e但我知道，焦虑不会就此消失。毕竟我已经大二了——大二的同辈有一年的学习积累，大一的新生又潜力无限。时间，终究不是站在我这边的\u0026hellip;\u003c/p\u003e\n\u003cp\u003e我不是《凡人修仙传》里的韩立，我没有小绿瓶，我也没有什么机缘，我只是一名普通的邮兵。我只能继续学习啊\u0026hellip;也许等未来我成为了一名架构师，维护着上亿人使用的app时，也会焦虑吧\u0026hellip;\u003c/p\u003e\n\u003cp\u003e不过现在的我身处迷雾之中，而未来又在何方呢？\u003c/p\u003e\n\u003cp\u003e焦虑啊，焦虑啊\u0026hellip;\u003c/p\u003e\n\u003cp\u003e也许成长就是这样——\u003cstrong\u003e一边焦虑，一边向前\u003c/strong\u003e\u0026hellip;\u003c/p\u003e\n\u003cp\u003e\u003cem\u003e写于 2025年10月26日 晚\u003c/em\u003e\u003c/p\u003e","title":"焦虑随想"},{"content":" ​\t这一周原本是大复特习的节奏，不过由于学校期中考的离谱安排，大学物理与概率论隔了两周时间，所以我就继续边学习边完成项目了。不过，有一说一，我觉得之前缺乏学习热情导致的原因还是陌生导致的，觉得很难，其实tag和原本的没什么不同，加个many2many，修改一下原本对tag的支持就基本完成了。\n已完成事项 完成了物理知识的复习（刷题之后再说吧） 完成了tag系统，并学习了Gorm的相关知识：many2many，关联模式的association()、replace()等 了解了cookie、session和token的知识概念，并在post记录了下来 了解了jwt的知识概念，跟着csdn上的一篇博客Gin 框架中如何实现 JWT 鉴权中间件初步学习了利用 jwt 包实现 web 鉴权 下周计划 数据结构刷点题（要考试了）🫠✅ 学习Viper来进行配置管理✅ 仿着csdn的那篇博客， 来实现 JWT 工具、编写登录/注册接口和编写鉴权中间件 ","permalink":"https://sheep44044.github.io/weekly/2025-10-20-weekly6/","summary":"\u003cblockquote\u003e\n\u003cp\u003e​\t这一周原本是大复特习的节奏，不过由于学校期中考的离谱安排，大学物理与概率论隔了两周时间，所以我就继续边学习边完成项目了。不过，有一说一，我觉得之前缺乏学习热情导致的原因还是陌生导致的，觉得很难，其实tag和原本的没什么不同，加个many2many，修改一下原本对tag的支持就基本完成了。\u003c/p\u003e\u003c/blockquote\u003e\n\u003ch2 id=\"已完成事项\"\u003e已完成事项\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e完成了物理知识的复习（刷题之后再说吧）\u003c/li\u003e\n\u003cli\u003e完成了tag系统，并学习了Gorm的相关知识：many2many，关联模式的association()、replace()等\u003c/li\u003e\n\u003cli\u003e了解了cookie、session和token的知识概念，并在post记录了下来\u003c/li\u003e\n\u003cli\u003e了解了jwt的知识概念，跟着csdn上的一篇博客\u003ca href=\"https://blog.csdn.net/hsuhwsb/article/details/149157912\"\u003eGin 框架中如何实现 JWT 鉴权中间件\u003c/a\u003e初步学习了利用 jwt 包实现 web 鉴权\u003c/li\u003e\n\u003c/ol\u003e\n\u003chr\u003e\n\u003ch2 id=\"下周计划\"\u003e下周计划\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e数据结构刷点题（要考试了）🫠✅\u003c/li\u003e\n\u003cli\u003e学习Viper来进行配置管理✅\u003c/li\u003e\n\u003cli\u003e仿着csdn的那篇博客， 来实现 JWT 工具、编写登录/注册接口和编写鉴权中间件\u003c/li\u003e\n\u003c/ol\u003e","title":"第六周总结"},{"content":"作为初学者，之前对于cookie、session和token的概念老是搞不清楚，现在搞懂了一些，就赶紧记下这一刻的知识，方便以后的查询。\n历史的演进是：Cookie -\u0026gt; Session (基于Cookie) -\u0026gt; Token (尤其是JWT)。\n1. Cookie Cookie 本身不进行验证，它只是一个存储和传输机制，一个携带信息的工具。在session出现之前，Cookie直接存储用户信息，十分不安全。\n2. Session session一般结合cookie使用，是存储在服务器，它会在服务器储存相关信息，设置session并返回sessionid，sessionid存储在客户端，每次登陆用cookie带上sessionid，去寻找session验证。\nSession 验证：类似于“查账本”的方式。服务器收到Session ID后，需要去数据库或内存中查找这个ID对应的Session数据。\n因为需要为每个活跃用户存储一份数据，所以存储量 = 用户数量 × 每个用户的数据大小，所以导致了技术上的限制：\nSession数据存储在单个服务器的内存中 在集群环境中，请求可能被负载均衡到不同服务器 除非所有服务器共享Session存储（如Redis），否则无法识别用户 3. Token token是存储在客户端的，相关信息存储在token的payload上，服务器只储存一个统一的密匙，用密匙进行验证。\ntoken验证：类似于“验证人民币”的方式。服务器中的密匙，根据token的header和payload验证签名。（header上的算法类似于开锁方法和说明书，密匙相当于那把钥匙，算法不等于密匙）\n因为只存储一份统一的密匙，所以存储量是个常量，天生符合分布式系统。\n4. 安全性 关于安全方面，不太清楚，就直接贴一下，AI的回答吧。\nSession 的安全核心是：Session ID 的保密性。一旦泄露，攻击者可以完全冒充用户，直到服务器端主动使其失效。 Token 的安全核心是：签名验证和短生命周期。它的设计一定程度上接受了“令牌可能会被偷”的现实，但通过技术手段限制其破坏力。 ","permalink":"https://sheep44044.github.io/posts/2025-10-19-cookie/","summary":"\u003cp\u003e作为初学者，之前对于cookie、session和token的概念老是搞不清楚，现在搞懂了一些，就赶紧记下这一刻的知识，方便以后的查询。\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e历史的演进是：\u003ccode\u003eCookie -\u0026gt; Session (基于Cookie) -\u0026gt; Token (尤其是JWT)\u003c/code\u003e。\u003c/p\u003e\n\u003ch2 id=\"1-cookie\"\u003e1. Cookie\u003c/h2\u003e\n\u003cp\u003eCookie 本身不进行验证，它只是一个存储和传输机制，一个携带信息的工具。在session出现之前，Cookie直接存储用户信息，十分不安全。\u003c/p\u003e\n\u003ch2 id=\"2-session\"\u003e2. Session\u003c/h2\u003e\n\u003cp\u003esession一般结合cookie使用，是存储在服务器，它会在服务器储存相关信息，设置session并返回sessionid，sessionid存储在客户端，每次登陆用cookie带上sessionid，去寻找session验证。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eSession 验证\u003c/strong\u003e：类似于“\u003cstrong\u003e查账本\u003c/strong\u003e”的方式。服务器收到Session ID后，需要去数据库或内存中\u003cstrong\u003e查找\u003c/strong\u003e这个ID对应的Session数据。\u003c/p\u003e\n\u003cp\u003e因为需要为每个活跃用户存储一份数据，所以\u003cstrong\u003e存储量 = 用户数量 × 每个用户的数据大小\u003c/strong\u003e，所以导致了技术上的限制：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eSession数据存储在\u003cstrong\u003e单个服务器\u003c/strong\u003e的内存中\u003c/li\u003e\n\u003cli\u003e在集群环境中，请求可能被负载均衡到不同服务器\u003c/li\u003e\n\u003cli\u003e除非所有服务器共享Session存储（如Redis），否则无法识别用户\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"3-token\"\u003e3. Token\u003c/h2\u003e\n\u003cp\u003etoken是存储在客户端的，相关信息存储在token的payload上，服务器只储存一个统一的密匙，用密匙进行验证。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003etoken验证\u003c/strong\u003e：类似于“\u003cstrong\u003e验证人民币\u003c/strong\u003e”的方式。服务器中的密匙，根据token的header和payload验证签名。（header上的算法类似于开锁方法和说明书，密匙相当于那把钥匙，\u003cstrong\u003e算法不等于密匙\u003c/strong\u003e）\u003c/p\u003e\n\u003cp\u003e因为只\u003cstrong\u003e存储一份统一的密匙\u003c/strong\u003e，所以存储量是个常量，天生符合分布式系统。\u003c/p\u003e\n\u003ch2 id=\"4-安全性\"\u003e4. 安全性\u003c/h2\u003e\n\u003cp\u003e关于安全方面，不太清楚，就直接贴一下，AI的回答吧。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eSession 的安全核心\u003c/strong\u003e是：Session ID 的\u003cstrong\u003e保密性\u003c/strong\u003e。一旦泄露，攻击者可以完全冒充用户，直到服务器端主动使其失效。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eToken 的安全核心\u003c/strong\u003e是：\u003cstrong\u003e签名验证\u003c/strong\u003e和\u003cstrong\u003e短生命周期\u003c/strong\u003e。它的设计一定程度上接受了“令牌可能会被偷”的现实，但通过技术手段限制其破坏力。\u003c/li\u003e\n\u003c/ul\u003e","title":"Cookie Session Token理解笔记"},{"content":" ​\t这一周可以以国庆为界可以分为两部分，第一部分是国企时期的对项目的推进即相关知识的学习。不过不知道是因为项目变复杂了，还是学习时间太久，感觉有点倦怠了🫩，于是，我便开始第二段是对期中考的学习。\n已完成事项 对 Gin 的继续学习，主要学习了路由组、使用中间件、自定义中间件、使用 BasicAuth 中间件的内容、JSON 的模型绑定和验证和自定义响应格式（不过现在有点忘了是什么了🫠） 对上周 Gorm 的复习，感觉基础的 Gorm 就是在 db.delete() 这些基础方法再加上 model()、where() 等来实现更多的、更准确的功能，也学习了 iserror 的错误判断 在 AI 的帮助下，实现了基本的分层项目结构，基本完成了上周的预期目标，理解了相关的内容（但是感觉如果自己独立写有点虚🫠） 开始期中考的学习，数据结构的知识基本学习完成（不过做题效果不是很好），通过蜂考学习大学物理的电磁学内容（至高斯定理部分），刚选择好概率论的 b 站视频😇 下周计划 继续期中考知识的学习✅ 如果学的快的话，会给项目写一个 tag 系统，为了从零搭建的实践，就像前面说的，感觉自己独立写有点虚🫠。✅ ","permalink":"https://sheep44044.github.io/weekly/2025-10-13-weekly5/","summary":"\u003cblockquote\u003e\n\u003cp\u003e​\t这一周可以以国庆为界可以分为两部分，第一部分是国企时期的对项目的推进即相关知识的学习。不过不知道是因为项目变复杂了，还是学习时间太久，感觉有点倦怠了🫩，于是，我便开始第二段是对期中考的学习。\u003c/p\u003e\u003c/blockquote\u003e\n\u003ch2 id=\"已完成事项\"\u003e已完成事项\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e对 Gin 的继续学习，主要学习了路由组、使用中间件、自定义中间件、使用 BasicAuth 中间件的内容、JSON 的模型绑定和验证和自定义响应格式（不过现在有点忘了是什么了🫠）\u003c/li\u003e\n\u003cli\u003e对上周 Gorm 的复习，感觉基础的 Gorm 就是在 \u003ccode\u003edb.delete()\u003c/code\u003e 这些基础方法再加上 \u003ccode\u003emodel()\u003c/code\u003e、\u003ccode\u003ewhere()\u003c/code\u003e 等来实现更多的、更准确的功能，也学习了 \u003ccode\u003eiserror\u003c/code\u003e 的错误判断\u003c/li\u003e\n\u003cli\u003e在 AI 的帮助下，实现了基本的分层项目结构，基本完成了上周的预期目标，理解了相关的内容（但是感觉如果自己独立写有点虚🫠）\u003c/li\u003e\n\u003cli\u003e开始期中考的学习，数据结构的知识基本学习完成（不过做题效果不是很好），通过蜂考学习大学物理的电磁学内容（至高斯定理部分），刚选择好概率论的 b 站视频😇\u003c/li\u003e\n\u003c/ol\u003e\n\u003chr\u003e\n\u003ch2 id=\"下周计划\"\u003e下周计划\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e继续期中考知识的学习✅\u003c/li\u003e\n\u003cli\u003e如果学的快的话，会给项目写一个 tag 系统，为了\u003cstrong\u003e从零搭建的实践\u003c/strong\u003e，就像前面说的，感觉自己独立写有点虚🫠。✅\u003c/li\u003e\n\u003c/ol\u003e","title":"第五周总结"},{"content":" ​\t由于上一周经历了国庆假期，星期一又是中秋节 🎑，所以拖着拖着，到了周二才开始写周报。不过，由于国庆假期摆烂的原因，也没什么好写的。但为了每周一份的周报，我还是在中秋节前夕，在 AI 的帮助下完成了一些内容，辅助着国庆前的老本，堪堪写一些内容。\n已完成事项 学习了 SQL 的语法，在 sql 之母上完成了十几道题目，对 SQL 有了基本的了解 学习了 Gorm 的概述、模型声明和 CRUD 接口等比较基础和简单的内容（自我感觉查询因为类似于 SQL 语法，更易懂点） 完成了智能笔记项目的 CRUD 内容，并连接上了 MySQL 数据库 下周计划 项目开发继续✅ 分层项目结构 统一响应与错误处理 .env 环境变量管理 结构化日志 \u0026hellip; 根据项目继续学习相关知识 Go 语言：错误处理、包管理、环境变量\u0026hellip; Gin：路由分组、中间件\u0026hellip;✅ Gorm：tag、错误处理\u0026hellip;✅ ","permalink":"https://sheep44044.github.io/weekly/2025-10-07-weekly4/","summary":"\u003cblockquote\u003e\n\u003cp\u003e​\t由于上一周经历了国庆假期，星期一又是中秋节 🎑，所以拖着拖着，到了周二才开始写周报。不过，由于国庆假期摆烂的原因，也没什么好写的。但为了每周一份的周报，我还是在中秋节前夕，在 AI 的帮助下完成了一些内容，辅助着国庆前的老本，堪堪写一些内容。\u003c/p\u003e\u003c/blockquote\u003e\n\u003ch2 id=\"已完成事项\"\u003e已完成事项\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e学习了 SQL 的语法，在 sql 之母上完成了十几道题目，对 SQL 有了基本的了解\u003c/li\u003e\n\u003cli\u003e学习了 Gorm 的概述、模型声明和 CRUD 接口等比较基础和简单的内容（自我感觉查询因为类似于 SQL 语法，更易懂点）\u003c/li\u003e\n\u003cli\u003e完成了智能笔记项目的 CRUD 内容，并连接上了 MySQL 数据库\u003c/li\u003e\n\u003c/ol\u003e\n\u003chr\u003e\n\u003ch2 id=\"下周计划\"\u003e下周计划\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e项目开发继续\u003c/strong\u003e✅\n\u003cul\u003e\n\u003cli\u003e分层项目结构\u003c/li\u003e\n\u003cli\u003e统一响应与错误处理\u003c/li\u003e\n\u003cli\u003e.env 环境变量管理\u003c/li\u003e\n\u003cli\u003e结构化日志\u003c/li\u003e\n\u003cli\u003e\u0026hellip;\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e根据项目继续学习相关知识\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003eGo 语言：错误处理、包管理、环境变量\u0026hellip;\u003c/li\u003e\n\u003cli\u003eGin：路由分组、中间件\u0026hellip;✅\u003c/li\u003e\n\u003cli\u003eGorm：tag、错误处理\u0026hellip;✅\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e","title":"第四周总结"},{"content":"面向对象，不知从何时起盘旋在我的脑海中，或许是学习Java，亦或是更早。不过，我一直都没特别理解这个东西，更不要说封装、继承等概念了，是我脑海中不断徘徊的乌云。直到现在，我重新审视，通过B站、知乎等网站，我终于有所感悟和理解，于是写下这篇文章。\n这里不着重于结构体和方法的理解和实现，只是单纯谈谈这个思想罢了👌\nOOP即面向对象编程(Object Oriented Programming)，与之相对的是面向过程编程。面向过程和面向对象的区别，用我在知乎上看到的一句话说就是——面向过程是编年体，面向对象是纪传体。\n面向过程，关注的是做事，关注的是\u0026quot;步骤\u0026quot;。把要实现的事情，拆分成一个个步骤，依次完成。解决问题时，思考的是\u0026quot;先做什么，再做什么，最后做什么\u0026quot;。在我看来这个视角类似于实施者，由于生活中我们就是以这种思想来生活，所以不可避免的更熟悉和理解面向过程编程。\n面向对象则不一样，它关注的是对象，是找人。解决问题时，思考的是\u0026quot;这个问题中有哪些参与者？这些参与者有哪些属性和行为？它们之间如何交互？\u0026ldquo;在这里，面向对象先把事务分解到对象身上，描述各个对象的作用，然后才是他们之间的交互。这里的视角类似于管理者。\n基于这一思想，面向对象发展出封装、继承和多态这三大特性。\n关于OOP的三特性形象化理解，假设你有一台洗衣机，要用它洗衣服，你关心它内部是怎么洗的么？你不关心，你只要按一个按钮就好了，这就是封装。不同型号的洗衣机洗衣方式不同，但是都能洗衣，而且你也只关心洗衣机的这个洗衣功能而已，所以你可以将全部洗衣机进行抽象，最终抽象出一个接口洗衣机，它有一个方法洗衣，这就是多态。相同品牌或者系列的洗衣机可能有类似的内部细节，这些细节可以组成一个模板，作为基类或者父类，而具体的某款产品则是子类，这是继承。 使用时，你通过上下文取得洗衣机接口的一个实例，调用其的洗衣方法，你就可以完成洗衣服操作了。至于它是如何洗衣服的你压根不关心。这就是OOP。\n在面向对象编程的概念中，类、对象、方法和属性在Java中体现的尤为明显，在Golang中则有不同的实现方式。\n传统OOP概念 Go中的实现 类(Class) 结构体(Struct) 对象(Object) 结构体实例(Struct Instance) 方法(Method) 带有接收者的函数(Method) 属性(Fields) 结构体字段(Struct Fields) 1. 封装 Go使用结构体和方法实现封装：\npackage main import \u0026#34;fmt\u0026#34; // 定义结构体（类似类） type Person struct { name string // 私有字段（小写开头） Age int // 公共字段（大写开头） } // 结构体方法（接收者） func (p *Person) GetName() string { return p.name } func (p *Person) SetName(name string) { p.name = name } func main() { p := Person{} p.SetName(\u0026#34;Alice\u0026#34;) p.Age = 30 fmt.Println(p.GetName()) // 输出: Alice fmt.Println(p.Age) // 输出: 30 } 2. 组合（替代继承） Go使用组合而不是继承来实现代码复用：\ntype Employee struct { Person // 嵌入Person，获得其所有字段和方法 Company string } func main() { e := Employee{} e.SetName(\u0026#34;Bob\u0026#34;) // 使用Person的方法 e.Age = 35 e.Company = \u0026#34;Google\u0026#34; fmt.Printf(\u0026#34;%s works at %s\u0026#34;, e.GetName(), e.Company) } 3. 多态（通过接口实现） Go的接口是隐式实现的，类型只需实现接口的所有方法：\n// 定义接口 type Speaker interface { Speak() string } // 实现接口的类型1 type Dog struct{} func (d Dog) Speak() string { return \u0026#34;Woof!\u0026#34; } // 实现接口的类型2 type Cat struct{} func (c Cat) Speak() string { return \u0026#34;Meow!\u0026#34; } func MakeSound(s Speaker) { fmt.Println(s.Speak()) } func main() { dog := Dog{} cat := Cat{} MakeSound(dog) // 输出: Woof! MakeSound(cat) // 输出: Meow! } ","permalink":"https://sheep44044.github.io/posts/2025-09-30-oop/","summary":"\u003cp\u003e面向对象，不知从何时起盘旋在我的脑海中，或许是学习Java，亦或是更早。不过，我一直都没特别理解这个东西，更不要说封装、继承等概念了，是我脑海中不断徘徊的乌云。直到现在，我重新审视，通过B站、知乎等网站，我终于有所感悟和理解，于是写下这篇文章。\u003c/p\u003e\n\u003cp\u003e这里不着重于结构体和方法的理解和实现，只是单纯谈谈这个思想罢了👌\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eOOP即面向对象编程(Object Oriented Programming)\u003c/strong\u003e，与之相对的是面向过程编程。面向过程和面向对象的区别，用我在知乎上看到的一句话说就是——\u003cstrong\u003e面向过程是编年体，面向对象是纪传体\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e面向过程\u003c/strong\u003e，关注的是做事，关注的是\u0026quot;步骤\u0026quot;。把要实现的事情，拆分成一个个步骤，依次完成。解决问题时，思考的是\u0026quot;先做什么，再做什么，最后做什么\u0026quot;。在我看来这个视角类似于实施者，由于生活中我们就是以这种思想来生活，所以不可避免的更熟悉和理解面向过程编程。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e面向对象\u003c/strong\u003e则不一样，它关注的是对象，是找人。解决问题时，思考的是\u0026quot;这个问题中有哪些\u003cstrong\u003e参与者\u003c/strong\u003e？这些参与者有哪些\u003cstrong\u003e属性\u003c/strong\u003e和\u003cstrong\u003e行为\u003c/strong\u003e？它们之间如何\u003cstrong\u003e交互\u003c/strong\u003e？\u0026ldquo;在这里，面向对象先把事务分解到对象身上，描述各个对象的作用，然后才是他们之间的交互。这里的视角类似于管理者。\u003c/p\u003e\n\u003cp\u003e基于这一思想，面向对象发展出\u003cstrong\u003e封装、继承和多态\u003c/strong\u003e这三大特性。\u003c/p\u003e\n\u003cp\u003e关于OOP的三特性形象化理解，假设你有一台洗衣机，要用它洗衣服，你关心它内部是怎么洗的么？你不关心，你只要按一个按钮就好了，这就是\u003cstrong\u003e封装\u003c/strong\u003e。不同型号的洗衣机洗衣方式不同，但是都能洗衣，而且你也只关心洗衣机的这个洗衣功能而已，所以你可以将全部洗衣机进行抽象，最终抽象出一个接口洗衣机，它有一个方法洗衣，这就是\u003cstrong\u003e多态\u003c/strong\u003e。相同品牌或者系列的洗衣机可能有类似的内部细节，这些细节可以组成一个模板，作为基类或者父类，而具体的某款产品则是子类，这是\u003cstrong\u003e继承\u003c/strong\u003e。 使用时，你通过上下文取得洗衣机接口的一个实例，调用其的洗衣方法，你就可以完成洗衣服操作了。至于它是如何洗衣服的你压根不关心。这就是OOP。\u003c/p\u003e\n\u003cp\u003e在面向对象编程的概念中，类、对象、方法和属性在Java中体现的尤为明显，在Golang中则有不同的实现方式。\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth style=\"text-align: left\"\u003e传统OOP概念\u003c/th\u003e\n          \u003cth style=\"text-align: left\"\u003eGo中的实现\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003e类(Class)\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e结构体(Struct)\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003e对象(Object)\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e结构体实例(Struct Instance)\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003e方法(Method)\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e带有接收者的函数(Method)\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003e属性(Fields)\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e结构体字段(Struct Fields)\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch3 id=\"1-封装\"\u003e1. 封装\u003c/h3\u003e\n\u003cp\u003eGo使用结构体和方法实现封装：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-go\" data-lang=\"go\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003epackage\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003emain\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003eimport\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;fmt\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// 定义结构体（类似类）\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etype\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ePerson\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003ename\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estring\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e// 私有字段（小写开头）\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003eAge\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e    \u003cspan style=\"color:#75715e\"\u003e// 公共字段（大写开头）\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// 结构体方法（接收者）\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003efunc\u003c/span\u003e (\u003cspan style=\"color:#a6e22e\"\u003ep\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e\u003cspan style=\"color:#a6e22e\"\u003ePerson\u003c/span\u003e) \u003cspan style=\"color:#a6e22e\"\u003eGetName\u003c/span\u003e() \u003cspan style=\"color:#66d9ef\"\u003estring\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ep\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003ename\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003efunc\u003c/span\u003e (\u003cspan style=\"color:#a6e22e\"\u003ep\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e\u003cspan style=\"color:#a6e22e\"\u003ePerson\u003c/span\u003e) \u003cspan style=\"color:#a6e22e\"\u003eSetName\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003ename\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estring\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003ep\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003ename\u003c/span\u003e = \u003cspan style=\"color:#a6e22e\"\u003ename\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003efunc\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003emain\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003ep\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e:=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ePerson\u003c/span\u003e{}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003ep\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eSetName\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;Alice\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003ep\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eAge\u003c/span\u003e = \u003cspan style=\"color:#ae81ff\"\u003e30\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003efmt\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003ePrintln\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003ep\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eGetName\u003c/span\u003e()) \u003cspan style=\"color:#75715e\"\u003e// 输出: Alice\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003efmt\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003ePrintln\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003ep\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eAge\u003c/span\u003e)       \u003cspan style=\"color:#75715e\"\u003e// 输出: 30\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"2-组合替代继承\"\u003e2. 组合（替代继承）\u003c/h3\u003e\n\u003cp\u003eGo使用组合而不是继承来实现代码复用：\u003c/p\u003e","title":"面向对象编程感悟"},{"content":"这个GitHub教育原来只是AI审核啊，怪不得我之前说了这么多人话，它都一秒给我拒了，我真是服了。这个AI太tm蠢了，怎么中文看不懂的，枉费我找了我的学生卡、学生证、录取通知书一点用都没有，还说了一大段话说我不用VPN连不上GitHub。\n最后还是在B站上取得真经。在备忘录里打了一段英文的话，说国庆节去旅游了所以ip在香港。最后，竟然过了。 哈哈哈～😂\n","permalink":"https://sheep44044.github.io/daily/2025-09-28-daily3/","summary":"\u003cp\u003e这个GitHub教育原来只是AI审核啊，怪不得我之前说了这么多人话，它都一秒给我拒了，我真是服了。这个AI太tm蠢了，怎么中文看不懂的，枉费我找了我的学生卡、学生证、录取通知书一点用都没有，还说了一大段话说我不用VPN连不上GitHub。\u003c/p\u003e\n\u003cp\u003e最后还是在B站上取得真经。在备忘录里打了一段英文的话，说国庆节去旅游了所以ip在香港。最后，竟然过了。 哈哈哈～😂\u003c/p\u003e","title":"愚蠢的我和GitHub教育"},{"content":"已完成事项 Go 语言学习 完成了 Tour of Go 的大部分练习。 但是也跳过了一些练习，image 接口等内容目前不急需；二叉查找树 等概念需要继续沉淀。 Go by Example 推进 已学习到 goroutine 的 rate-limiting 部分。 重点学习了闭包和goroutine及其timer、tickers、waitgroup 等内容。 但是也跳过了 范型、枚举、迭代器的 range 等目前不会的内容。 项目开发 - 智能笔记 开始完成智能笔记项目，准备一边学一边开发。 迈出第一步：成功让 API 服务运行起来。 Gin 框架学习 初步开始Gin的学习，掌握了 HTTP 方法、路由、路由参数、JSON、Query 和 Post Form 的使用。 计划在后续开发 JWT、日志 等功能时进行更深入的学习。 工具与环境 安装了 Postman、MySQL 等开发工具。 成功申请了 GitHub 教育福利（费了我好大劲，在使用 VPN 的情况下）。 下周计划 项目开发继续✅ 学习 SQL 基础语法。 初步学习 Gorm。 实现笔记的完整 CRUD 功能。 实现数据持久化，接入 MySQL 数据库。 学校课业（可能） 可能需要回顾学校知识，为 10 月中下旬 的期中考做准备。 ","permalink":"https://sheep44044.github.io/weekly/2025-09-29-weekly3/","summary":"\u003ch2 id=\"已完成事项\"\u003e已完成事项\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003eGo 语言学习\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e完成了 \u003ccode\u003eTour of Go\u003c/code\u003e 的大部分练习。\u003c/li\u003e\n\u003cli\u003e但是也跳过了一些练习，\u003ccode\u003eimage\u003c/code\u003e 接口等内容目前不急需；\u003ccode\u003e二叉查找树\u003c/code\u003e 等概念需要继续沉淀。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eGo by Example 推进\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e已学习到 \u003ccode\u003egoroutine\u003c/code\u003e 的 \u003ccode\u003erate-limiting\u003c/code\u003e 部分。\u003c/li\u003e\n\u003cli\u003e重点学习了\u003ccode\u003e闭包\u003c/code\u003e和\u003ccode\u003egoroutine\u003c/code\u003e及其\u003ccode\u003etimer\u003c/code\u003e、\u003ccode\u003etickers\u003c/code\u003e、\u003ccode\u003ewaitgroup\u003c/code\u003e 等内容。\u003c/li\u003e\n\u003cli\u003e但是也跳过了 \u003ccode\u003e范型\u003c/code\u003e、\u003ccode\u003e枚举\u003c/code\u003e、\u003ccode\u003e迭代器的 range\u003c/code\u003e 等目前不会的内容。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e项目开发 - 智能笔记\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e开始完成智能笔记项目，准备一边学一边开发。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e迈出第一步\u003c/strong\u003e：成功让 API 服务运行起来。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eGin 框架学习\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e初步开始Gin的学习，掌握了 \u003ccode\u003eHTTP 方法\u003c/code\u003e、\u003ccode\u003e路由\u003c/code\u003e、\u003ccode\u003e路由参数\u003c/code\u003e、\u003ccode\u003eJSON\u003c/code\u003e、\u003ccode\u003eQuery\u003c/code\u003e 和 \u003ccode\u003ePost Form\u003c/code\u003e 的使用。\u003c/li\u003e\n\u003cli\u003e计划在后续开发 \u003ccode\u003eJWT\u003c/code\u003e、\u003ccode\u003e日志\u003c/code\u003e 等功能时进行更深入的学习。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e工具与环境\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e安装了 \u003ccode\u003ePostman\u003c/code\u003e、\u003ccode\u003eMySQL\u003c/code\u003e 等开发工具。\u003c/li\u003e\n\u003cli\u003e成功申请了 \u003ccode\u003eGitHub 教育福利\u003c/code\u003e（费了我好大劲，在使用 VPN 的情况下）。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003chr\u003e\n\u003ch2 id=\"下周计划\"\u003e下周计划\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e项目开发继续\u003c/strong\u003e✅\n\u003cul\u003e\n\u003cli\u003e学习 \u003ccode\u003eSQL\u003c/code\u003e 基础语法。\u003c/li\u003e\n\u003cli\u003e初步学习 \u003ccode\u003eGorm\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003e实现笔记的完整 \u003cstrong\u003eCRUD\u003c/strong\u003e 功能。\u003c/li\u003e\n\u003cli\u003e实现数据持久化，接入 \u003ccode\u003eMySQL\u003c/code\u003e 数据库。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e学校课业（可能）\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e可能\u003c/strong\u003e需要回顾学校知识，为 \u003cstrong\u003e10 月中下旬\u003c/strong\u003e 的期中考做准备。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e","title":"第三周总结"},{"content":"woc,这个gin的文档怎么这么傻逼啊，它的example的例子竟然是tm安照首字母排序的！我真的🙃蚌不住了，真的好笑，我🤡tm看了A开头的AsciiJSON半天，没搞懂gin的基础和它有什么关系。我还看了下面有什么自定义HTTP配置，日志文件什么的，我以为是我没怎么学net/http包的问题。屮，谁知道我前面几个都看不懂的无助感，真以为要被技术文档阻挡下来了，要中道崩殂了。\n幸好😅我问了ai，发现基础的是在后面的使用HTTP方法。复活了😑，耶🫠\u0026hellip;\n点\u0026mdash;\u0026gt;🤡\u0026lt;\u0026mdash;击\n好吧，其实我后面看了一下，它似乎是在quick start这里是正常的，按知识难度从基础到困难排的，不过它的注释是英文的，谷歌翻译翻译不到他，所以 一样\n","permalink":"https://sheep44044.github.io/daily/2025-09-26-daily2/","summary":"\u003cp\u003ewoc,这个gin的文档怎么这么傻逼啊，它的example的例子竟然是tm安照首字母排序的！我真的🙃蚌不住了，真的好笑，我🤡tm看了A开头的AsciiJSON半天，没搞懂gin的基础和它有什么关系。我还看了下面有什么自定义HTTP配置，日志文件什么的，我以为是我没怎么学net/http包的问题。屮，谁知道我前面几个都看不懂的无助感，真以为要被技术文档阻挡下来了，要中道崩殂了。\u003c/p\u003e\n\u003cp\u003e幸好😅我问了ai，发现基础的是在后面的使用HTTP方法。复活了😑，耶🫠\u0026hellip;\u003c/p\u003e\n\u003cp\u003e点\u0026mdash;\u0026gt;\u003ca href=\"https://gin-gonic.com/zh-cn/docs/\"\u003e🤡\u003c/a\u003e\u0026lt;\u0026mdash;击\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e好吧，其实我后面看了一下，它似乎是在quick start这里是正常的，按知识难度从基础到困难排的，不过它的注释是英文的，谷歌翻译翻译不到他，所以 一样\u003c/p\u003e","title":"fuck gin"},{"content":"woc，这个string 和 rune怎么这么麻烦😡，我有点看不懂了，以后再看吧👀\n现在先标记一下吧，以后看看(不过go的博客确实不赖，不过我现在太菜了，看不懂)\ngobyexample的字符串\nGo 中的字符串、字节、符文和字符\n","permalink":"https://sheep44044.github.io/daily/2025-09-23-daily1/","summary":"\u003cp\u003ewoc，这个string 和 rune怎么这么麻烦😡，我有点看不懂了，以后再看吧👀\u003c/p\u003e\n\u003cp\u003e现在先标记一下吧，以后看看(不过go的博客确实不赖，不过我现在太菜了，看不懂)\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://gobyexample.com/strings-and-runes\"\u003egobyexample的字符串\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://go.dev/blog/strings\"\u003eGo 中的字符串、字节、符文和字符\u003c/a\u003e\u003c/p\u003e","title":"巴拉巴拉"},{"content":"完成事项 解决了上周博客留下来的问题，有了一个简陋但功能完备的网站 🥳。 在 Tour of Go 上基本完成了所有内容的学习，包括切片、接口、并发等知识点。 持续推进 Go by Example 的学习，目前完成 switch 部分，进入数组相关内容（不得不说gobyexample确实不赖，对于这些基础知识我也能学到新的特性）。 做了一些学习笔记。 下周计划 巩固已学知识，搞懂 Tour of Go 中的练习题。✅ 继续学习 Go by Example 的后续内容。✅ （可能）了解一些常用标准库包的基本用法。 ","permalink":"https://sheep44044.github.io/weekly/2025-09-22-weekly2/","summary":"\u003ch2 id=\"完成事项\"\u003e完成事项\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e解决了上周博客留下来的问题，有了一个简陋但功能完备的网站 🥳。\u003c/li\u003e\n\u003cli\u003e在 \u003ca href=\"https://tour.go-zh.org/\"\u003eTour of Go\u003c/a\u003e 上基本完成了所有内容的学习，包括切片、接口、并发等知识点。\u003c/li\u003e\n\u003cli\u003e持续推进 \u003ca href=\"https://gobyexample.com/\"\u003eGo by Example\u003c/a\u003e 的学习，目前完成 \u003ccode\u003eswitch\u003c/code\u003e 部分，进入数组相关内容（不得不说gobyexample确实不赖，对于这些基础知识我也能学到新的特性）。\u003c/li\u003e\n\u003cli\u003e做了一些学习笔记。\u003c/li\u003e\n\u003c/ol\u003e\n\u003chr\u003e\n\u003ch2 id=\"下周计划\"\u003e下周计划\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e巩固已学知识，搞懂 Tour of Go 中的练习题。✅\u003c/li\u003e\n\u003cli\u003e继续学习 Go by Example 的后续内容。✅\u003c/li\u003e\n\u003cli\u003e（可能）了解一些常用标准库包的基本用法。\u003c/li\u003e\n\u003c/ol\u003e","title":"第二周总结"},{"content":"Golang之接口 接口是我在tour of go上遇到的第一个难点，因此我打算再开一篇来着重记录，不仅是当下对此的沉淀与思考，也是对未来的提醒与照应。为了方便自己的查看，便独立于之前的知识碎片。\n接口（interface） 接口的定义 接口（Interface）本质上就是定义了一组方法签名（Method Signatures）的集合。它只关心**“做什么”，而不关心“怎么做”**。\n它规定：“任何类型，只要你实现了我的合同里规定的所有这些方法，那我就认为你实现了这个接口。”\n每个接口类型由任意个方法签名组成，接口的定义格式如下：\ntype 接口类型名 interface{ 方法名1( 参数列表1 ) 返回值列表1 方法名2( 参数列表2 ) 返回值列表2 … } 如何实现接口？（“隐式实现”） Go 接口的实现是 “隐式” 的。这意味着你不需要像 Java 那样明确地写 implements Speaker。只需要让这个类型拥有接口里规定的所有方法，它就自动实现了该接口！\n这是 Go 的哲学——“鸭子类型”（如果它走起来像鸭子，叫起来像鸭子，那它就是鸭子）。\n接口值 接口也是值。它们可以像其它值一样传递。\n接口值可以用作函数的参数或返回值。\n接口值可以看作两部分具体类型和该类型的值。\n可以把接口值想象成一个特殊的“盒子”。\n这个盒子上贴着一个标签，写着里面装的东西的类型（*main.Dog）。 盒子里装着实际的值（一个 Dog 结构体的实例）。 var s Speaker // 接口变量 s，此时它是一个空的“盒子”，里面是 nil s = Dog{Name: \u0026#34;Rex\u0026#34;} // 赋值后，s 这个“盒子”里： // - 标签：main.Dog // - 值：{Rex} fmt.Printf(\u0026#34;(%v, %T)\\n\u0026#34;, s, s) // 输出：({Rex}, main.Dog) // 值部分 和 类型部分 当你调用 s.Speak() 时，Go 会打开这个“盒子”，根据标签找到类型 Dog，然后执行 Dog 的 Speak 方法。\n底层值为 nil 的接口值 即便接口内的具体值为 nil，方法仍然会被 nil 接收者调用。保存了 nil 具体值的接口其自身并不为 nil。\nnil 接口值 nil 接口值既不保存值也不保存具体类型。\n为 nil 接口调用方法会产生运行时错误，因为接口的元组内并未包含能够指明该调用哪个 具体 方法的类型。\n空接口（interface{}/any） 空接口可保存任何类型的值（因为每个类型都至少实现了零个方法）\n空接口被用来处理未知类型的值\ntips：\n空接口是一个接口类型。因为它没有规定任何方法，所以Go语言规定所有类型都自动实现了空接口。\nnil接口值指的是一个接口变量的当前状态是“空”的。\n它们之间的关系是正交的：你可以有一个空接口类型的nil接口值，也可以有一个非空的自定义接口类型的nil接口值。\n类型断言 由于接口变量可以持有任意实现它的类型的值，有时我们需要知道它背后具体的实际值是什么。\n在 Go 语言中，接口断言是一种检查接口变量是否具有特定具体类型的方法。接口断言的基本语法如下：\nvalue, ok := interfaceVariable.(Type) 其中：\ninterfaceVariable 是一个接口类型的变量 Type 是你想要断言的具体类型 如果 interfaceVariable 实际上是一个 Type 类型的值，那么 value 将会被赋值为该值，并且 ok 将会是 true。如果 interfaceVariable 不是 Type 类型，那么 value 将会是 Type 类型的零值，而 ok 将会是 false 对于空接口 interface{}，任何类型的值都可以被赋值给它，因此对接口断言的需求更加常见 类型选择 类型选择 是一种按顺序从几个类型断言中选择分支的结构。\n类型选择与一般的 switch 语句相似，不过类型选择中的 case 为类型（而非值）， 它们针对给定接口值所存储的值的类型进行比较。\nswitch v := i.(type) { case T: // v 的类型为 T case S: // v 的类型为 S default: // 没有匹配，v 与 i 的类型相同 } 类型选择中的声明与类型断言 i.(T) 的语法相同，只是具体类型 T 被替换成了关键字 type。\n多态实现 接口变量可以持有任意实现它的类型的值\n多态（Polymorphism） 指的是一个接口的调用方式，可以在运行时根据其底层实际类型的不同而表现出不同的行为\n核心思想： 不同结构体只要实现了相同的接口，它们就可以被当作同一种类型（接口类型）来处理，但在执行接口方法时，会执行各自具体的实现。\n经典例子：\npackage main import \u0026#34;fmt\u0026#34; // 定义一个支付接口 type Payment interface { Pay(amount float64) string } // 实现两种不同的支付方式 type Alipay struct { Account string } func (a Alipay) Pay(amount float64) string { return fmt.Sprintf(\u0026#34;使用支付宝 %s 支付了 %.2f 元\u0026#34;, a.Account, amount) } type WechatPay struct { OpenID string } func (w WechatPay) Pay(amount float64) string { return fmt.Sprintf(\u0026#34;使用微信 %s 支付了 %.2f 元\u0026#34;, w.OpenID, amount) } // 一个通用的支付函数，它只关心传入的对象是否实现了 Payment 接口 func ProcessPayment(p Payment, amount float64) { result := p.Pay(amount) fmt.Println(result) } func main() { a := Alipay{Account: \u0026#34;zhangsan@alipay.com\u0026#34;} w := WechatPay{OpenID: \u0026#34;wx_abcdef123456\u0026#34;} // 多态的体现：ProcessPayment 函数不需要知道具体是哪种支付方式 // 它只需要调用 Pay 方法，而具体执行哪个版本的 Pay，由运行时 p 的实际类型决定 ProcessPayment(a, 100.5) ProcessPayment(w, 200.0) // 也可以将不同的实现放入同一个切片（接口类型切片） payments := []Payment{a, w} for _, payer := range payments { ProcessPayment(payer, 50.0) } } 输出：\n使用支付宝 zhangsan@alipay.com 支付了 100.50 元 使用微信 wx_abcdef123456 支付了 200.00 元 使用支付宝 zhangsan@alipay.com 支付了 50.00 元 使用微信 wx_abcdef123456 支付了 50.00 元 Go的\u0026quot;继承\u0026quot; Go 语言设计者认为传统的类继承（尤其是多重继承）模型复杂且容易出错。因此，Go 彻底摒弃了 class 和 extends 的概念。\nGo 的“继承”是通过结构体的嵌套（Embedding）来实现的，这本质上是“组合”。\n// “父类”（基类） type Animal struct { name string } func (a *Animal) Speak() { fmt.Println(\u0026#34;我是:\u0026#34;, a.name) } // “子类”（派生类），通过嵌入 Animal 来“继承”它的字段和方法 type Dog struct { Animal // 嵌入 Animal，实现了组合 Breed string // 子类自己的字段 } // 子类可以重写父类的方法 func (d *Dog) Speak() { d.Animal.Speak() // 可以调用“父类”的方法 fmt.Println(\u0026#34;汪汪汪！\u0026#34;) } func main() { d := Dog{ Animal: Animal{name: \u0026#34;旺财\u0026#34;}, // 初始化嵌入的结构体 Breed: \u0026#34;柯基\u0026#34;, } d.Speak() // 调用子类重写后的方法 d.Animal.Speak() // 仍然可以显式调用父类的方法 } 这种组合的优势：\n清晰简单：没有复杂的继承链。 解耦：Dog 和 Animal 是两个独立的类型，Dog 只是使用了 Animal 的功能。 灵活性：Dog 可以轻松组合多个其他结构体（例如 Pet）的功能，模拟了“多重继承”，但又没有多重继承的歧义问题。 常见的接口 1.Stringer fmt 包中定义的 Stringer 是最普遍的接口之一。\ntype Stringer interface { String() string } Stringer 是一个可以用字符串描述自己的类型。fmt 包（还有很多包）都通过此接口来打印值。\n2.error Go 程序使用 error 值来表示错误状态。\n与 fmt.Stringer 类似，error 类型是一个内建接口：\ntype error interface { Error() string } （与 fmt.Stringer 类似，fmt 包也会根据对 error 的实现来打印值。）\n通常函数会返回一个 error 值，调用它的代码应当判断这个错误是否等于 nil 来进行错误处理。\ni, err := strconv.Atoi(\u0026#34;42\u0026#34;) if err != nil { fmt.Printf(\u0026#34;couldn\u0026#39;t convert number: %v\\n\u0026#34;, err) return } fmt.Println(\u0026#34;Converted integer:\u0026#34;, i) error 为 nil 时表示成功；非 nil 的 error 表示失败。\n3.Readers io 包指定了 io.Reader 接口，它表示数据流的读取端。\nGo 标准库包含了该接口的许多实现，包括文件、网络连接、压缩和加密等等。\nio.Reader 接口有一个 Read 方法：\nfunc (T) Read(b []byte) (n int, err error) Read 用数据填充给定的字节切片并返回填充的字节数和错误值。在遇到数据流的结尾时，它会返回一个 io.EOF 错误。\n4.Image image 包定义了 Image 接口：\npackage image type Image interface { ColorModel() color.Model Bounds() Rectangle At(x, y int) color.Color } 注意: Bounds 方法的返回值 Rectangle 实际上是一个 image.Rectangle，它在 image 包中声明。\n","permalink":"https://sheep44044.github.io/posts/2025-09-19-interface/","summary":"\u003ch1 id=\"golang之接口\"\u003eGolang之接口\u003c/h1\u003e\n\u003cp\u003e接口是我在tour of go上遇到的第一个难点，因此我打算再开一篇来着重记录，不仅是当下对此的沉淀与思考，也是对未来的提醒与照应。为了方便自己的查看，便独立于之前的知识碎片。\u003c/p\u003e\n\u003ch2 id=\"接口interface\"\u003e接口（interface）\u003c/h2\u003e\n\u003ch3 id=\"接口的定义\"\u003e接口的定义\u003c/h3\u003e\n\u003cp\u003e接口（Interface）本质上就是\u003cstrong\u003e定义了一组方法签名（Method Signatures）的集合\u003c/strong\u003e。它只关心**“做什么”\u003cstrong\u003e，而不关心\u003c/strong\u003e“怎么做”**。\u003c/p\u003e\n\u003cp\u003e它规定：\u003cstrong\u003e“任何类型，只要你实现了我的合同里规定的所有这些方法，那我就认为你实现了这个接口。”\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e每个接口类型由任意个方法签名组成，接口的定义格式如下：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-go\" data-lang=\"go\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etype\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003e接口类型名\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003einterface\u003c/span\u003e{\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003e方法名1\u003c/span\u003e( \u003cspan style=\"color:#a6e22e\"\u003e参数列表1\u003c/span\u003e ) \u003cspan style=\"color:#a6e22e\"\u003e返回值列表1\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003e方法名2\u003c/span\u003e( \u003cspan style=\"color:#a6e22e\"\u003e参数列表2\u003c/span\u003e ) \u003cspan style=\"color:#a6e22e\"\u003e返回值列表2\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e…\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"如何实现接口隐式实现\"\u003e如何实现接口？（“隐式实现”）\u003c/h3\u003e\n\u003cp\u003eGo 接口的实现是 \u003cstrong\u003e“隐式”\u003c/strong\u003e 的。这意味着你\u003cstrong\u003e不需要\u003c/strong\u003e像 Java 那样明确地写 \u003ccode\u003eimplements Speaker\u003c/code\u003e。只需要让这个类型拥有接口里规定的所有方法，它就自动实现了该接口！\u003c/p\u003e\n\u003cp\u003e这是 Go 的哲学——“鸭子类型”（如果它走起来像鸭子，叫起来像鸭子，那它就是鸭子）。\u003c/p\u003e\n\u003ch2 id=\"接口值\"\u003e接口值\u003c/h2\u003e\n\u003cp\u003e接口也是值。它们可以像其它值一样传递。\u003c/p\u003e\n\u003cp\u003e接口值可以用作函数的参数或返回值。\u003c/p\u003e\n\u003cp\u003e接口值可以看作两部分\u003cstrong\u003e具体类型\u003c/strong\u003e和\u003cstrong\u003e该类型的值\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e可以把接口值想象成一个特殊的“盒子”。\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e这个盒子上贴着一个\u003cstrong\u003e标签\u003c/strong\u003e，写着里面装的东西的类型（\u003ccode\u003e*main.Dog\u003c/code\u003e）。\u003c/li\u003e\n\u003cli\u003e盒子里装着\u003cstrong\u003e实际的值\u003c/strong\u003e（一个 \u003ccode\u003eDog\u003c/code\u003e 结构体的实例）。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-go\" data-lang=\"go\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003evar\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003es\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eSpeaker\u003c/span\u003e      \u003cspan style=\"color:#75715e\"\u003e// 接口变量 s，此时它是一个空的“盒子”，里面是 nil\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003es\u003c/span\u003e = \u003cspan style=\"color:#a6e22e\"\u003eDog\u003c/span\u003e{\u003cspan style=\"color:#a6e22e\"\u003eName\u003c/span\u003e: \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;Rex\u0026#34;\u003c/span\u003e} \u003cspan style=\"color:#75715e\"\u003e// 赋值后，s 这个“盒子”里：\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                     \u003cspan style=\"color:#75715e\"\u003e// - 标签：main.Dog\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                     \u003cspan style=\"color:#75715e\"\u003e// - 值：{Rex}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003efmt\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003ePrintf\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;(%v, %T)\\n\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003es\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003es\u003c/span\u003e) \u003cspan style=\"color:#75715e\"\u003e// 输出：({Rex}, main.Dog)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                               \u003cspan style=\"color:#75715e\"\u003e// 值部分 和 类型部分\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e当你调用 \u003ccode\u003es.Speak()\u003c/code\u003e 时，Go 会打开这个“盒子”，根据标签找到类型 \u003ccode\u003eDog\u003c/code\u003e，然后执行 \u003ccode\u003eDog\u003c/code\u003e 的 \u003ccode\u003eSpeak\u003c/code\u003e 方法。\u003c/p\u003e","title":"Golang之接口"},{"content":"Golang的知识碎片 在此之前golang单纯看蓝山的文档，感觉学的很浅很零碎，所以打算重新看一遍。因为go by example、tour go和蓝山工作室的文档比较完善，所以下方将着重提及一些之前不太清楚的零碎知识，提醒自己。\n0.Go 语言的零值机制\n在 Go 语言中，所有变量在声明时都会被自动初始化为其类型的零值（zero value）：\n数值类型：0 布尔类型：false 字符串类型：\u0026quot;\u0026quot;（空字符串） 指针、接口、切片、映射、通道：nil 结构体：每个字段都初始化为其类型的零值 1.变量声明\n关于变量的声明包括两部分，类型和初始值，变量会从初始值中推断出类型或从类型中推断出初始值（即零值）\n2.返回值\nGo 的返回值可以被命名（向前面的参数一样），return后面没有参数，就会返回没有命名的返回值\n3.条件语句前简短语句\nfor和if 语句可以在条件表达式前执行一个简短语句\n4.无条件的switch(类似于if-else)\nswitch { case x \u0026lt; 0: fmt.Println(\u0026#34;Negative\u0026#34;) case x == 0: fmt.Println(\u0026#34;Zero\u0026#34;) default: fmt.Println(\u0026#34;Positive\u0026#34;) } 5.defer推迟/defer栈\ndefer 语句会将函数调用推迟到外层函数返回之后执行 被推迟的函数调用会被压入一个栈中，当外层函数返回时，被推迟的函数会按照后进先出（LIFO）的顺序执行 6.函数闭包\n闭包 = 函数 + 外部变量变量\n状态保持：闭包可以记住并修改外部变量 独立实例：每次调用外部函数都会创建新的闭包实例 实用性强：用于需要保持状态的场景 如何判断外部变量\n\u0026ldquo;这个变量是在内层函数内部定义的，还是外部定义的？\u0026rdquo; 再问：\u0026ldquo;内层函数是否使用了这个外部变量？\u0026rdquo; 如果两个答案都是\u0026quot;是\u0026quot;：那么这个变量就是被捕获的外部变量 7.方法\n方法可以看作有接收者的函数，不过带指针/值参数的函数必须接受一个指针/值，不然会报错，而以指针/值为接收者的方法被调用时，接收者既能为值又能为指针，不过能不能生效另说\n8.接收者类型\n接收者有两种类型，值接收者和指针接收者。\n使用指针接收者的两个原因：\n1.方法需要修改接收者的值，值接收者只能改变副本，指针可以改变原始值\n2.提高效率，每次方法调用时，Go 需要将整个结构体的数据复制一份给方法使用。如果结构体非常大，这个复制操作的开销会很大。而Go 只需要复制一个指针（通常是一个机器字长的大小，如 8 字节），开销极小。\n所以，大部分的时候使用指针\ntips\n对于一个特定的类型，你应该决定是使用值接收者还是指针接收者，并为该类型的所有方法保持一致。\n9.值类型/引用类型\n这是 Go 语言中一个非常重要的概念，决定了变量如何被分配内存、如何被赋值以及如何被传递给函数。\n值类型 (Value Types) 包括： 所有基本数据类型（如 int, float64, bool, string）、数组（Array）、结构体（struct）。 行为特点： 变量直接存储值本身。 赋值操作和函数传参时，会创建值的完整副本。 修改副本不会影响原始值。 在内存中，通常被分配在栈（Stack） 上（但编译器也可能决定分配在堆上）。 // 值类型示例：数组 arr1 := [3]int{1, 2, 3} arr2 := arr1 // 将 arr1 的【所有值】完整地复制一份给 arr2 arr2[0] = 100 // 修改副本 fmt.Println(arr1) // 输出: [1 2 3] (原值未改变) fmt.Println(arr2) // 输出: [100 2 3] 引用类型 (Reference Types) 包括： 切片（Slice）、映射（Map）、通道（Channel）、指针（Pointer）、函数（Function）。 行为特点： 变量存储的是一个“引用”（可以理解为内存地址），这个引用指向底层真正存储数据的内存空间。 赋值操作和函数传参时，复制的是这个“引用”（内存地址），而不是底层数据本身。 多个变量可以共享同一份底层数据。通过任何一个变量修改底层数据，其他所有引用它的变量都会“看到”这个变化。 底层数据通常存储在堆（Heap） 上。 // 引用类型示例：切片 slice1 := []int{1, 2, 3} slice2 := slice1 // 复制的是引用（地址），现在 slice1 和 slice2 指向同一个底层数组 slice2[0] = 100 // 通过 slice2 修改底层数组 fmt.Println(slice1) // 输出: [100 2 3] (原值被改变了！) fmt.Println(slice2) // 输出: [100 2 3] 总结对比表 特性 值类型 引用类型 代表类型 int, array, struct, string slice, map, channel, pointer 变量存储内容 实际的数据值 指向底层数据的地址（引用） 赋值/传参行为 复制整个数据值，创建独立副本 复制引用地址，共享底层数据 修改副本的影响 不影响原始数据 影响原始数据 内存主要位置 栈 堆（数据本身），变量本身可能在栈 10.匿名函数/结构体\u0026hellip;\n暂时不太懂，标记一下\n","permalink":"https://sheep44044.github.io/posts/first-post/","summary":"\u003ch1 id=\"golang的知识碎片\"\u003eGolang的知识碎片\u003c/h1\u003e\n\u003cp\u003e在此之前golang单纯看蓝山的文档，感觉学的很浅很零碎，所以打算重新看一遍。因为go by example、tour go和蓝山工作室的文档比较完善，所以下方将着重提及一些之前不太清楚的零碎知识，提醒自己。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e0.Go 语言的零值机制\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e在 Go 语言中，所有变量在声明时都会被自动初始化为其类型的\u003cstrong\u003e零值\u003c/strong\u003e（zero value）：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e数值类型：\u003ccode\u003e0\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e布尔类型：\u003ccode\u003efalse\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e字符串类型：\u003ccode\u003e\u0026quot;\u0026quot;\u003c/code\u003e（空字符串）\u003c/li\u003e\n\u003cli\u003e指针、接口、切片、映射、通道：\u003ccode\u003enil\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e结构体：每个字段都初始化为其类型的零值\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e1.变量声明\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e关于变量的声明包括两部分，类型和初始值，变量会从初始值中推断出类型或从类型中推断出初始值（即零值）\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e2.返回值\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eGo 的返回值可以被命名（向前面的参数一样），return后面没有参数，就会返回没有命名的返回值\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e3.条件语句前简短语句\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003efor和\u003ccode\u003eif\u003c/code\u003e 语句可以在条件表达式前执行一个简短语句\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e4.无条件的switch(类似于if-else)\u003c/strong\u003e\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-go\" data-lang=\"go\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eswitch\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003ecase\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ex\u003c/span\u003e \u0026lt; \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003efmt\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003ePrintln\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;Negative\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003ecase\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ex\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003efmt\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003ePrintln\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;Zero\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003edefault\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003efmt\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003ePrintln\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;Positive\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\u003cstrong\u003e5.defer推迟/defer栈\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003edefer\u003c/code\u003e 语句会将函数调用推迟到外层函数返回之后执行\u003c/li\u003e\n\u003cli\u003e被推迟的函数调用会被压入一个\u003cstrong\u003e栈\u003c/strong\u003e中，当外层函数返回时，被推迟的函数会按照\u003cstrong\u003e后进先出\u003c/strong\u003e（LIFO）的顺序执行\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e6.函数闭包\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e闭包 = 函数 + 外部变量变量\u003c/strong\u003e\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e状态保持\u003c/strong\u003e：闭包可以记住并修改外部变量\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e独立实例\u003c/strong\u003e：每次调用外部函数都会创建新的闭包实例\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e实用性强\u003c/strong\u003e：用于需要保持状态的场景\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e如何判断外部变量\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u0026ldquo;这个变量是在内层函数内部定义的，还是外部定义的？\u0026rdquo;\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e再问\u003c/strong\u003e：\u0026ldquo;内层函数是否使用了这个外部变量？\u0026rdquo;\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e如果两个答案都是\u0026quot;是\u0026quot;\u003c/strong\u003e：那么这个变量就是被捕获的外部变量\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cstrong\u003e7.方法\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e方法可以看作有接收者的函数，不过带指针/值参数的函数必须接受一个指针/值，不然会报错，而以指针/值为接收者的方法被调用时，接收者既能为值又能为指针，不过能不能生效另说\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e8.接收者类型\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e接收者有两种类型，\u003cstrong\u003e值接收者\u003c/strong\u003e和\u003cstrong\u003e指针接收者\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e使用指针接收者的两个原因：\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e1.方法需要修改接收者的值，值接收者只能改变副本，指针可以改变原始值\u003c/p\u003e\n\u003cp\u003e2.提高效率，每次方法调用时，Go 需要将整个结构体的数据\u003cstrong\u003e复制\u003c/strong\u003e一份给方法使用。如果结构体非常大，这个复制操作的开销会很大。而Go 只需要复制一个\u003cstrong\u003e指针\u003c/strong\u003e（通常是一个机器字长的大小，如 8 字节），开销极小。\u003c/p\u003e\n\u003cp\u003e所以，大部分的时候使用指针\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003etips\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e对于一个特定的类型，你应该决定是使用值接收者还是指针接收者，并\u003cstrong\u003e为该类型的所有方法保持一致\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e9.值类型/引用类型\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e这是 Go 语言中一个非常重要的概念，决定了变量如何被分配内存、如何被赋值以及如何被传递给函数。\u003c/p\u003e","title":"Golang的知识碎片（基础篇）"},{"content":"本周主要完成了以下三件事情：\n完成事项 熟悉 Mac 并配置软件环境\n开始熟悉 macOS 操作系统。 使用 Jetbrans Toolbox 安装 Goland 等开发工具。 通过 Homebrew 包管理器安装并管理 Git、Typora 等软件。 学习并使用 Git\n通过教程网站 learngitbranching.js.org 的git小游戏来学习和练习 Git 操作。 成功配置 Git 并与我的 GitHub 账户进行关联。 实现了在 Goland IDE 中集成并使用 Git。 利用 Hugo 搭建博客\n使用 Hugo 静态网站生成器初步搭建了个人博客。 实现了基本功能：主页文章展示、包含“文章”和“周报”等菜单的导航栏。 下周计划 解决博客的一个小问题：博客在互联网上登入时会错误跳转到本地。✅ 复习 Golang 的知识。✅ ","permalink":"https://sheep44044.github.io/weekly/weekly-1/","summary":"\u003cp\u003e本周主要完成了以下三件事情：\u003c/p\u003e\n\u003ch2 id=\"完成事项\"\u003e完成事项\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e熟悉 Mac 并配置软件环境\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e开始熟悉 macOS 操作系统。\u003c/li\u003e\n\u003cli\u003e使用 Jetbrans Toolbox 安装 Goland 等开发工具。\u003c/li\u003e\n\u003cli\u003e通过 Homebrew 包管理器安装并管理 Git、Typora 等软件。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e学习并使用 Git\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e通过教程网站 \u003ca href=\"https://learngitbranching.js.org/?demo=\u0026amp;locale=zh_CN\"\u003elearngitbranching.js.org\u003c/a\u003e 的git小游戏来学习和练习 Git 操作。\u003c/li\u003e\n\u003cli\u003e成功配置 Git 并与我的 GitHub 账户进行关联。\u003c/li\u003e\n\u003cli\u003e实现了在 Goland IDE 中集成并使用 Git。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e利用 Hugo 搭建博客\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e使用 \u003ccode\u003eHugo\u003c/code\u003e 静态网站生成器初步搭建了个人博客。\u003c/li\u003e\n\u003cli\u003e实现了基本功能：主页文章展示、包含“文章”和“周报”等菜单的导航栏。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003chr\u003e\n\u003ch2 id=\"下周计划\"\u003e下周计划\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e解决博客的一个小问题：博客在互联网上登入时会错误跳转到本地。✅\u003c/li\u003e\n\u003cli\u003e复习 Golang 的知识。✅\u003c/li\u003e\n\u003c/ul\u003e","title":"第一周总结"},{"content":"关于我 🥳\n我是 sheep44044，一名CQUPT的24级学生🧑‍🎓，一名对世界充满好奇的探索者。\n🚀 我正在学习：Git, Golang 以及其他有趣的开发技术。 📝 我正在记录：学习过程中的思考、总结和牢骚😩。 🎃 我的兴趣：代码、游戏、发呆ing。 🎯 展望\n提升自己 留点时间给自己 探索些感兴趣的东西 这个博客是我成长路上的数字脚印，也是你眼前看到的第一个小成果！旨在记录和分享我的学习历程与偶尔的碎碎念。如果这里的内容能给你带来一丝启发或帮助，那将是我最大的荣幸。\n💌 联系我：3290120053@qq.com\n🐙 GitHub: sheep44044\n感谢你的到访！期待与你交流。祝你今天过得愉快！✨\n","permalink":"https://sheep44044.github.io/about/","summary":"\u003cp\u003e关于我 🥳\u003c/p\u003e\n\u003cp\u003e我是 \u003cstrong\u003esheep44044\u003c/strong\u003e，一名CQUPT的24级学生🧑‍🎓，一名对世界充满好奇的探索者。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e🚀 \u003cstrong\u003e我正在学习\u003c/strong\u003e：Git, Golang 以及其他有趣的开发技术。\u003c/li\u003e\n\u003cli\u003e📝 \u003cstrong\u003e我正在记录\u003c/strong\u003e：学习过程中的思考、总结和牢骚😩。\u003c/li\u003e\n\u003cli\u003e🎃 \u003cstrong\u003e我的兴趣\u003c/strong\u003e：代码、游戏、发呆ing。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e🎯 展望\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e提升自己\u003c/li\u003e\n\u003cli\u003e留点时间给自己\u003c/li\u003e\n\u003cli\u003e探索些感兴趣的东西\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e这个博客是我成长路上的数字脚印，也是你眼前看到的第一个小成果！旨在记录和分享我的学习历程与偶尔的碎碎念。如果这里的内容能给你带来一丝启发或帮助，那将是我最大的荣幸。\u003c/p\u003e\n\u003cp\u003e💌 \u003cstrong\u003e联系我\u003c/strong\u003e：\u003ccode\u003e3290120053@qq.com\u003c/code\u003e\u003cbr\u003e\n🐙 \u003cstrong\u003eGitHub\u003c/strong\u003e: \u003ca href=\"https://github.com/sheep44044\"\u003esheep44044\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e感谢你的到访！期待与你交流。祝你今天过得愉快！✨\u003c/p\u003e","title":"关于我"},{"content":"种一棵树最好的时间是十年前，其次是现在。 大一的时候，我初出茅庐，渴望着完美，绩点、开发、算法一并取得，最后什么都没拿到。\n现在，希望专注于一点，取得一丝成就吧。\n— 2025.9.13\n只有选择，没有对错，喜欢的事，勇敢去做，不要怕，不喜欢的事，尽力而为，听从自己内心的选择。\n在网上，人们说大学最好的时光是在高中时，最好的高中时光在大学生活中。回顾高中三年，我却难以会想起我自身的成就和生活的美好，就连学习也没有学到什么——周末、寒暑去补课，最终，却还是需要父母的帮助才来到重邮。\n悟以往之不谏，知来者之可追。我希望能通过日记来记录自己的学习，亦是提醒自己不要忘记过去的遗憾和那每年的30000元学费。\n我希望能通过自己的蜕变，逐渐成长，达成以下目标：\n拿到奖学金 通过红岩和蓝山的考核 进入ACM集训队 拿到地区的奖牌 获得浙大的录取通知书或是大厂的offer 虽然我的目标实现十分困难，也没有任何实现的依据。但是，我希望借此来激发自己，成为别人口中聪明的孩子，对得起父母、自己和每年的30000元。\n这些想法积聚我脑中已久，借此，我想放空我的脑袋，把这些情绪与计划一同放于日记中，付诸更多的行动，来更好地学习。至于对象、健身这些对我虚无缥缈的东西，尽力而为吧。\nFIGHTing — 2024.11.8\n","permalink":"https://sheep44044.github.io/daily/my-first-post/","summary":"\u003ch1 id=\"种一棵树最好的时间是十年前其次是现在\"\u003e种一棵树最好的时间是十年前，其次是现在。\u003c/h1\u003e\n\u003cp\u003e大一的时候，我初出茅庐，渴望着完美，绩点、开发、算法一并取得，最后什么都没拿到。\u003c/p\u003e\n\u003cp\u003e现在，希望专注于一点，取得一丝成就吧。\u003cbr\u003e\n— 2025.9.13\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e只有选择，没有对错，喜欢的事，勇敢去做，不要怕，不喜欢的事，尽力而为，听从自己内心的选择。\u003c/p\u003e\n\u003cp\u003e在网上，人们说大学最好的时光是在高中时，最好的高中时光在大学生活中。回顾高中三年，我却难以会想起我自身的成就和生活的美好，就连学习也没有学到什么——周末、寒暑去补课，最终，却还是需要父母的帮助才来到重邮。\u003c/p\u003e\n\u003cp\u003e悟以往之不谏，知来者之可追。我希望能通过日记来记录自己的学习，亦是提醒自己不要忘记过去的遗憾和那每年的30000元学费。\u003c/p\u003e\n\u003cp\u003e我希望能通过自己的蜕变，逐渐成长，达成以下目标：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e拿到奖学金\u003c/li\u003e\n\u003cli\u003e通过红岩和蓝山的考核\u003c/li\u003e\n\u003cli\u003e进入ACM集训队\u003c/li\u003e\n\u003cli\u003e拿到地区的奖牌\u003c/li\u003e\n\u003cli\u003e获得浙大的录取通知书或是大厂的offer\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e虽然我的目标实现十分困难，也没有任何实现的依据。但是，我希望借此来激发自己，成为别人口中聪明的孩子，对得起父母、自己和每年的30000元。\u003c/p\u003e\n\u003cp\u003e这些想法积聚我脑中已久，借此，我想放空我的脑袋，把这些情绪与计划一同放于日记中，付诸更多的行动，来更好地学习。至于对象、健身这些对我虚无缥缈的东西，尽力而为吧。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eFIGHTing\u003c/strong\u003e       — 2024.11.8\u003c/p\u003e","title":"My First Post"}]