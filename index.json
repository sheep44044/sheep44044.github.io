[{"content":"作为初学者，之前对于cookie、session和token的概念老是搞不清楚，现在搞懂了一些，就赶紧记下这一刻的知识，方便以后的查询。\n历史的演进是：Cookie -\u0026gt; Session (基于Cookie) -\u0026gt; Token (尤其是JWT)。\n1. Cookie Cookie 本身不进行验证，它只是一个存储和传输机制，一个携带信息的工具。在session出现之前，Cookie直接存储用户信息，十分不安全。\n2. Session session一般结合cookie使用，是存储在服务器，它会在服务器储存相关信息，设置session并返回sessionid，sessionid存储在客户端，每次登陆用cookie带上sessionid，去寻找session验证。\nSession 验证：类似于“查账本”的方式。服务器收到Session ID后，需要去数据库或内存中查找这个ID对应的Session数据。\n因为需要为每个活跃用户存储一份数据，所以存储量 = 用户数量 × 每个用户的数据大小，所以导致了技术上的限制：\nSession数据存储在单个服务器的内存中 在集群环境中，请求可能被负载均衡到不同服务器 除非所有服务器共享Session存储（如Redis），否则无法识别用户 3. Token token是存储在客户端的，相关信息存储在token的payload上，服务器只储存一个统一的密匙，用密匙进行验证。\ntoken验证：类似于“验证人民币”的方式。服务器中的密匙，根据token的header和payload验证签名。（header上的算法类似于开锁方法和说明书，密匙相当于那把钥匙，算法不等于密匙）\n因为只存储一份统一的密匙，所以存储量是个常量，天生符合分布式系统。\n4.安全性 关于安全方面，不太清楚，就直接贴一下，AI的回答吧。\nSession 的安全核心是：Session ID 的保密性。一旦泄露，攻击者可以完全冒充用户，直到服务器端主动使其失效。 Token 的安全核心是：签名验证和短生命周期。它的设计一定程度上接受了“令牌可能会被偷”的现实，但通过技术手段限制其破坏力。 ","permalink":"https://sheep44044.github.io/posts/2025-10-19-cookie/","summary":"\u003cp\u003e作为初学者，之前对于cookie、session和token的概念老是搞不清楚，现在搞懂了一些，就赶紧记下这一刻的知识，方便以后的查询。\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e历史的演进是：\u003ccode\u003eCookie -\u0026gt; Session (基于Cookie) -\u0026gt; Token (尤其是JWT)\u003c/code\u003e。\u003c/p\u003e\n\u003ch2 id=\"1-cookie\"\u003e1. Cookie\u003c/h2\u003e\n\u003cp\u003eCookie 本身不进行验证，它只是一个存储和传输机制，一个携带信息的工具。在session出现之前，Cookie直接存储用户信息，十分不安全。\u003c/p\u003e\n\u003ch2 id=\"2-session\"\u003e2. Session\u003c/h2\u003e\n\u003cp\u003esession一般结合cookie使用，是存储在服务器，它会在服务器储存相关信息，设置session并返回sessionid，sessionid存储在客户端，每次登陆用cookie带上sessionid，去寻找session验证。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eSession 验证\u003c/strong\u003e：类似于“\u003cstrong\u003e查账本\u003c/strong\u003e”的方式。服务器收到Session ID后，需要去数据库或内存中\u003cstrong\u003e查找\u003c/strong\u003e这个ID对应的Session数据。\u003c/p\u003e\n\u003cp\u003e因为需要为每个活跃用户存储一份数据，所以\u003cstrong\u003e存储量 = 用户数量 × 每个用户的数据大小\u003c/strong\u003e，所以导致了技术上的限制：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eSession数据存储在\u003cstrong\u003e单个服务器\u003c/strong\u003e的内存中\u003c/li\u003e\n\u003cli\u003e在集群环境中，请求可能被负载均衡到不同服务器\u003c/li\u003e\n\u003cli\u003e除非所有服务器共享Session存储（如Redis），否则无法识别用户\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"3-token\"\u003e3. Token\u003c/h2\u003e\n\u003cp\u003etoken是存储在客户端的，相关信息存储在token的payload上，服务器只储存一个统一的密匙，用密匙进行验证。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003etoken验证\u003c/strong\u003e：类似于“\u003cstrong\u003e验证人民币\u003c/strong\u003e”的方式。服务器中的密匙，根据token的header和payload验证签名。（header上的算法类似于开锁方法和说明书，密匙相当于那把钥匙，\u003cstrong\u003e算法不等于密匙\u003c/strong\u003e）\u003c/p\u003e\n\u003cp\u003e因为只\u003cstrong\u003e存储一份统一的密匙\u003c/strong\u003e，所以存储量是个常量，天生符合分布式系统。\u003c/p\u003e\n\u003ch3 id=\"4安全性\"\u003e4.安全性\u003c/h3\u003e\n\u003cp\u003e关于安全方面，不太清楚，就直接贴一下，AI的回答吧。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eSession 的安全核心\u003c/strong\u003e是：Session ID 的\u003cstrong\u003e保密性\u003c/strong\u003e。一旦泄露，攻击者可以完全冒充用户，直到服务器端主动使其失效。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eToken 的安全核心\u003c/strong\u003e是：\u003cstrong\u003e签名验证\u003c/strong\u003e和\u003cstrong\u003e短生命周期\u003c/strong\u003e。它的设计一定程度上接受了“令牌可能会被偷”的现实，但通过技术手段限制其破坏力。\u003c/li\u003e\n\u003c/ul\u003e","title":"Cookie Session Token理解笔记"},{"content":"第五周学习总结 这一周可以以国庆为界可以分为两部分，第一部分是国企时期的对项目的推进即相关知识的学习。不过不知道是因为项目变复杂了，还是学习时间太久，感觉有点倦怠了🫩，于是，我便开始第二段是对期中考的学习。\n已完成事项 对 Gin 的继续学习，主要学习了路由组、使用中间件、自定义中间件、使用 BasicAuth 中间件的内容、JSON 的模型绑定和验证和自定义响应格式（不过现在有点忘了是什么了🫠） 对上周 Gorm 的复习，感觉基础的 Gorm 就是在 db.delete() 这些基础方法再加上 model()、where() 等来实现更多的、更准确的功能，也学习了 iserror 的错误判断 在 AI 的帮助下，实现了基本的分层项目结构，基本完成了上周的预期目标，理解了相关的内容（但是感觉如果自己独立写有点虚🫠） 开始期中考的学习，数据结构的知识基本学习完成（不过做题效果不是很好），通过蜂考学习大学物理的电磁学内容（至高斯定理部分），刚选择好概率论的 b 站视频😇 下周计划 继续期中考知识的学习 如果学的快的话，会给项目写一个 tag 系统，为了从零搭建的实践，就像前面说的，感觉自己独立写有点虚🫠。不改变内容，转换成 md 格式 ","permalink":"https://sheep44044.github.io/weekly/2025-10-13-weekly5/","summary":"\u003ch1 id=\"第五周学习总结\"\u003e第五周学习总结\u003c/h1\u003e\n\u003cp\u003e这一周可以以国庆为界可以分为两部分，第一部分是国企时期的对项目的推进即相关知识的学习。不过不知道是因为项目变复杂了，还是学习时间太久，感觉有点倦怠了🫩，于是，我便开始第二段是对期中考的学习。\u003c/p\u003e\n\u003ch2 id=\"已完成事项\"\u003e已完成事项\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e对 Gin 的继续学习，主要学习了路由组、使用中间件、自定义中间件、使用 BasicAuth 中间件的内容、JSON 的模型绑定和验证和自定义响应格式（不过现在有点忘了是什么了🫠）\u003c/li\u003e\n\u003cli\u003e对上周 Gorm 的复习，感觉基础的 Gorm 就是在 \u003ccode\u003edb.delete()\u003c/code\u003e 这些基础方法再加上 \u003ccode\u003emodel()\u003c/code\u003e、\u003ccode\u003ewhere()\u003c/code\u003e 等来实现更多的、更准确的功能，也学习了 \u003ccode\u003eiserror\u003c/code\u003e 的错误判断\u003c/li\u003e\n\u003cli\u003e在 AI 的帮助下，实现了基本的分层项目结构，基本完成了上周的预期目标，理解了相关的内容（但是感觉如果自己独立写有点虚🫠）\u003c/li\u003e\n\u003cli\u003e开始期中考的学习，数据结构的知识基本学习完成（不过做题效果不是很好），通过蜂考学习大学物理的电磁学内容（至高斯定理部分），刚选择好概率论的 b 站视频😇\u003c/li\u003e\n\u003c/ol\u003e\n\u003chr\u003e\n\u003ch2 id=\"下周计划\"\u003e下周计划\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e继续期中考知识的学习\u003c/li\u003e\n\u003cli\u003e如果学的快的话，会给项目写一个 tag 系统，为了\u003cstrong\u003e从零搭建的实践\u003c/strong\u003e，就像前面说的，感觉自己独立写有点虚🫠。不改变内容，转换成 md 格式\u003c/li\u003e\n\u003c/ol\u003e","title":"第五周总结"},{"content":"第四周学习总结 由于上一周经历了国庆假期，星期一又是中秋节 🎑，所以拖着拖着，到了周二才开始写周报。不过，由于国庆假期摆烂的原因，也没什么好写的。但为了每周一份的周报，我还是在中秋节前夕，在 AI 的帮助下完成了一些内容，辅助着国庆前的老本，堪堪写一些内容。\n已完成事项 学习了 SQL 的语法，在 sql 之母上完成了十几道题目，对 SQL 有了基本的了解 学习了 Gorm 的概述、模型声明和 CRUD 接口等比较基础和简单的内容（自我感觉查询因为类似于 SQL 语法，更易懂点） 完成了智能笔记项目的 CRUD 内容，并连接上了 MySQL 数据库 下周计划 项目开发继续✅ 分层项目结构 统一响应与错误处理 .env 环境变量管理 结构化日志 \u0026hellip; 根据项目继续学习相关知识 Go 语言：错误处理、包管理、环境变量\u0026hellip; Gin：路由分组、中间件\u0026hellip;✅ Gorm：tag、错误处理\u0026hellip;✅ ","permalink":"https://sheep44044.github.io/weekly/2025-10-07-weekly4/","summary":"\u003ch1 id=\"第四周学习总结\"\u003e第四周学习总结\u003c/h1\u003e\n\u003cp\u003e由于上一周经历了国庆假期，星期一又是中秋节 🎑，所以拖着拖着，到了周二才开始写周报。不过，由于国庆假期摆烂的原因，也没什么好写的。但为了每周一份的周报，我还是在中秋节前夕，在 AI 的帮助下完成了一些内容，辅助着国庆前的老本，堪堪写一些内容。\u003c/p\u003e\n\u003ch2 id=\"已完成事项\"\u003e已完成事项\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e学习了 SQL 的语法，在 sql 之母上完成了十几道题目，对 SQL 有了基本的了解\u003c/li\u003e\n\u003cli\u003e学习了 Gorm 的概述、模型声明和 CRUD 接口等比较基础和简单的内容（自我感觉查询因为类似于 SQL 语法，更易懂点）\u003c/li\u003e\n\u003cli\u003e完成了智能笔记项目的 CRUD 内容，并连接上了 MySQL 数据库\u003c/li\u003e\n\u003c/ol\u003e\n\u003chr\u003e\n\u003ch2 id=\"下周计划\"\u003e下周计划\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e项目开发继续\u003c/strong\u003e✅\n\u003cul\u003e\n\u003cli\u003e分层项目结构\u003c/li\u003e\n\u003cli\u003e统一响应与错误处理\u003c/li\u003e\n\u003cli\u003e.env 环境变量管理\u003c/li\u003e\n\u003cli\u003e结构化日志\u003c/li\u003e\n\u003cli\u003e\u0026hellip;\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e根据项目继续学习相关知识\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003eGo 语言：错误处理、包管理、环境变量\u0026hellip;\u003c/li\u003e\n\u003cli\u003eGin：路由分组、中间件\u0026hellip;✅\u003c/li\u003e\n\u003cli\u003eGorm：tag、错误处理\u0026hellip;✅\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e","title":"第四周总结"},{"content":"面向对象，不知从何时起盘旋在我的脑海中，或许是学习Java，亦或是更早。不过，我一直都没特别理解这个东西，更不要说封装、继承等概念了，是我脑海中不断徘徊的乌云。直到现在，我重新审视，通过B站、知乎等网站，我终于有所感悟和理解，于是写下这篇文章。\n这里不着重于结构体和方法的理解和实现，只是单纯谈谈这个思想罢了👌\nOOP即面向对象编程(Object Oriented Programming)，与之相对的是面向过程编程。面向过程和面向对象的区别，用我在知乎上看到的一句话说就是——面向过程是编年体，面向对象是纪传体。\n面向过程，关注的是做事，关注的是\u0026quot;步骤\u0026quot;。把要实现的事情，拆分成一个个步骤，依次完成。解决问题时，思考的是\u0026quot;先做什么，再做什么，最后做什么\u0026quot;。在我看来这个视角类似于实施者，由于生活中我们就是以这种思想来生活，所以不可避免的更熟悉和理解面向过程编程。\n面向对象则不一样，它关注的是对象，是找人。解决问题时，思考的是\u0026quot;这个问题中有哪些参与者？这些参与者有哪些属性和行为？它们之间如何交互？\u0026ldquo;在这里，面向对象先把事务分解到对象身上，描述各个对象的作用，然后才是他们之间的交互。这里的视角类似于管理者。\n基于这一思想，面向对象发展出封装、继承和多态这三大特性。\n关于OOP的三特性形象化理解，假设你有一台洗衣机，要用它洗衣服，你关心它内部是怎么洗的么？你不关心，你只要按一个按钮就好了，这就是封装。不同型号的洗衣机洗衣方式不同，但是都能洗衣，而且你也只关心洗衣机的这个洗衣功能而已，所以你可以将全部洗衣机进行抽象，最终抽象出一个接口洗衣机，它有一个方法洗衣，这就是多态。相同品牌或者系列的洗衣机可能有类似的内部细节，这些细节可以组成一个模板，作为基类或者父类，而具体的某款产品则是子类，这是继承。 使用时，你通过上下文取得洗衣机接口的一个实例，调用其的洗衣方法，你就可以完成洗衣服操作了。至于它是如何洗衣服的你压根不关心。这就是OOP。\n在面向对象编程的概念中，类、对象、方法和属性在Java中体现的尤为明显，在Golang中则有不同的实现方式。\n传统OOP概念 Go中的实现 类(Class) 结构体(Struct) 对象(Object) 结构体实例(Struct Instance) 方法(Method) 带有接收者的函数(Method) 属性(Fields) 结构体字段(Struct Fields) 1. 封装 Go使用结构体和方法实现封装：\npackage main import \u0026#34;fmt\u0026#34; // 定义结构体（类似类） type Person struct { name string // 私有字段（小写开头） Age int // 公共字段（大写开头） } // 结构体方法（接收者） func (p *Person) GetName() string { return p.name } func (p *Person) SetName(name string) { p.name = name } func main() { p := Person{} p.SetName(\u0026#34;Alice\u0026#34;) p.Age = 30 fmt.Println(p.GetName()) // 输出: Alice fmt.Println(p.Age) // 输出: 30 } 2. 组合（替代继承） Go使用组合而不是继承来实现代码复用：\ntype Employee struct { Person // 嵌入Person，获得其所有字段和方法 Company string } func main() { e := Employee{} e.SetName(\u0026#34;Bob\u0026#34;) // 使用Person的方法 e.Age = 35 e.Company = \u0026#34;Google\u0026#34; fmt.Printf(\u0026#34;%s works at %s\u0026#34;, e.GetName(), e.Company) } 3. 多态（通过接口实现） Go的接口是隐式实现的，类型只需实现接口的所有方法：\n// 定义接口 type Speaker interface { Speak() string } // 实现接口的类型1 type Dog struct{} func (d Dog) Speak() string { return \u0026#34;Woof!\u0026#34; } // 实现接口的类型2 type Cat struct{} func (c Cat) Speak() string { return \u0026#34;Meow!\u0026#34; } func MakeSound(s Speaker) { fmt.Println(s.Speak()) } func main() { dog := Dog{} cat := Cat{} MakeSound(dog) // 输出: Woof! MakeSound(cat) // 输出: Meow! } ","permalink":"https://sheep44044.github.io/posts/2025-09-30-oop/","summary":"\u003cp\u003e面向对象，不知从何时起盘旋在我的脑海中，或许是学习Java，亦或是更早。不过，我一直都没特别理解这个东西，更不要说封装、继承等概念了，是我脑海中不断徘徊的乌云。直到现在，我重新审视，通过B站、知乎等网站，我终于有所感悟和理解，于是写下这篇文章。\u003c/p\u003e\n\u003cp\u003e这里不着重于结构体和方法的理解和实现，只是单纯谈谈这个思想罢了👌\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eOOP即面向对象编程(Object Oriented Programming)\u003c/strong\u003e，与之相对的是面向过程编程。面向过程和面向对象的区别，用我在知乎上看到的一句话说就是——\u003cstrong\u003e面向过程是编年体，面向对象是纪传体\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e面向过程\u003c/strong\u003e，关注的是做事，关注的是\u0026quot;步骤\u0026quot;。把要实现的事情，拆分成一个个步骤，依次完成。解决问题时，思考的是\u0026quot;先做什么，再做什么，最后做什么\u0026quot;。在我看来这个视角类似于实施者，由于生活中我们就是以这种思想来生活，所以不可避免的更熟悉和理解面向过程编程。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e面向对象\u003c/strong\u003e则不一样，它关注的是对象，是找人。解决问题时，思考的是\u0026quot;这个问题中有哪些\u003cstrong\u003e参与者\u003c/strong\u003e？这些参与者有哪些\u003cstrong\u003e属性\u003c/strong\u003e和\u003cstrong\u003e行为\u003c/strong\u003e？它们之间如何\u003cstrong\u003e交互\u003c/strong\u003e？\u0026ldquo;在这里，面向对象先把事务分解到对象身上，描述各个对象的作用，然后才是他们之间的交互。这里的视角类似于管理者。\u003c/p\u003e\n\u003cp\u003e基于这一思想，面向对象发展出\u003cstrong\u003e封装、继承和多态\u003c/strong\u003e这三大特性。\u003c/p\u003e\n\u003cp\u003e关于OOP的三特性形象化理解，假设你有一台洗衣机，要用它洗衣服，你关心它内部是怎么洗的么？你不关心，你只要按一个按钮就好了，这就是\u003cstrong\u003e封装\u003c/strong\u003e。不同型号的洗衣机洗衣方式不同，但是都能洗衣，而且你也只关心洗衣机的这个洗衣功能而已，所以你可以将全部洗衣机进行抽象，最终抽象出一个接口洗衣机，它有一个方法洗衣，这就是\u003cstrong\u003e多态\u003c/strong\u003e。相同品牌或者系列的洗衣机可能有类似的内部细节，这些细节可以组成一个模板，作为基类或者父类，而具体的某款产品则是子类，这是\u003cstrong\u003e继承\u003c/strong\u003e。 使用时，你通过上下文取得洗衣机接口的一个实例，调用其的洗衣方法，你就可以完成洗衣服操作了。至于它是如何洗衣服的你压根不关心。这就是OOP。\u003c/p\u003e\n\u003cp\u003e在面向对象编程的概念中，类、对象、方法和属性在Java中体现的尤为明显，在Golang中则有不同的实现方式。\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth style=\"text-align: left\"\u003e传统OOP概念\u003c/th\u003e\n          \u003cth style=\"text-align: left\"\u003eGo中的实现\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003e类(Class)\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e结构体(Struct)\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003e对象(Object)\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e结构体实例(Struct Instance)\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003e方法(Method)\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e带有接收者的函数(Method)\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003e属性(Fields)\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e结构体字段(Struct Fields)\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch3 id=\"1-封装\"\u003e1. 封装\u003c/h3\u003e\n\u003cp\u003eGo使用结构体和方法实现封装：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-go\" data-lang=\"go\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003epackage\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003emain\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003eimport\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;fmt\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// 定义结构体（类似类）\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etype\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ePerson\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003ename\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estring\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e// 私有字段（小写开头）\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003eAge\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e    \u003cspan style=\"color:#75715e\"\u003e// 公共字段（大写开头）\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// 结构体方法（接收者）\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003efunc\u003c/span\u003e (\u003cspan style=\"color:#a6e22e\"\u003ep\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e\u003cspan style=\"color:#a6e22e\"\u003ePerson\u003c/span\u003e) \u003cspan style=\"color:#a6e22e\"\u003eGetName\u003c/span\u003e() \u003cspan style=\"color:#66d9ef\"\u003estring\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ep\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003ename\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003efunc\u003c/span\u003e (\u003cspan style=\"color:#a6e22e\"\u003ep\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e\u003cspan style=\"color:#a6e22e\"\u003ePerson\u003c/span\u003e) \u003cspan style=\"color:#a6e22e\"\u003eSetName\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003ename\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estring\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003ep\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003ename\u003c/span\u003e = \u003cspan style=\"color:#a6e22e\"\u003ename\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003efunc\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003emain\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003ep\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e:=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ePerson\u003c/span\u003e{}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003ep\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eSetName\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;Alice\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003ep\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eAge\u003c/span\u003e = \u003cspan style=\"color:#ae81ff\"\u003e30\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003efmt\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003ePrintln\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003ep\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eGetName\u003c/span\u003e()) \u003cspan style=\"color:#75715e\"\u003e// 输出: Alice\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003efmt\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003ePrintln\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003ep\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eAge\u003c/span\u003e)       \u003cspan style=\"color:#75715e\"\u003e// 输出: 30\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"2-组合替代继承\"\u003e2. 组合（替代继承）\u003c/h3\u003e\n\u003cp\u003eGo使用组合而不是继承来实现代码复用：\u003c/p\u003e","title":"面向对象编程感悟"},{"content":"这个GitHub教育原来只是AI审核啊，怪不得我之前说了这么多人话，它都一秒给我拒了，我真是服了。这个AI太tm蠢了，怎么中文看不懂的，枉费我找了我的学生卡、学生证、录取通知书一点用都没有，还说了一大段话说我不用VPN连不上GitHub。\n最后还是在B站上取得真经。在备忘录里打了一段英文的话，说国庆节去旅游了所以ip在香港。最后，竟然过了。 哈哈哈～😂\n","permalink":"https://sheep44044.github.io/daily/2025-09-28-daily3/","summary":"\u003cp\u003e这个GitHub教育原来只是AI审核啊，怪不得我之前说了这么多人话，它都一秒给我拒了，我真是服了。这个AI太tm蠢了，怎么中文看不懂的，枉费我找了我的学生卡、学生证、录取通知书一点用都没有，还说了一大段话说我不用VPN连不上GitHub。\u003c/p\u003e\n\u003cp\u003e最后还是在B站上取得真经。在备忘录里打了一段英文的话，说国庆节去旅游了所以ip在香港。最后，竟然过了。 哈哈哈～😂\u003c/p\u003e","title":"愚蠢的我和GitHub教育"},{"content":"第三周学习总结 已完成事项 Go 语言学习 完成了 Tour of Go 的大部分练习。 但是也跳过了一些练习，image 接口等内容目前不急需；二叉查找树 等概念需要继续沉淀。 Go by Example 推进 已学习到 goroutine 的 rate-limiting 部分。 重点学习了闭包和goroutine及其timer、tickers、waitgroup 等内容。 但是也跳过了 范型、枚举、迭代器的 range 等目前不会的内容。 项目开发 - 智能笔记 开始完成智能笔记项目，准备一边学一边开发。 迈出第一步：成功让 API 服务运行起来。 Gin 框架学习 初步开始Gin的学习，掌握了 HTTP 方法、路由、路由参数、JSON、Query 和 Post Form 的使用。 计划在后续开发 JWT、日志 等功能时进行更深入的学习。 工具与环境 安装了 Postman、MySQL 等开发工具。 成功申请了 GitHub 教育福利（费了我好大劲，在使用 VPN 的情况下）。 下周计划 项目开发继续✅ 学习 SQL 基础语法。 初步学习 Gorm。 实现笔记的完整 CRUD 功能。 实现数据持久化，接入 MySQL 数据库。 学校课业（可能） 可能需要回顾学校知识，为 10 月中下旬 的期中考做准备。 ","permalink":"https://sheep44044.github.io/weekly/2025-09-29-weekly3/","summary":"\u003ch1 id=\"第三周学习总结\"\u003e第三周学习总结\u003c/h1\u003e\n\u003ch2 id=\"已完成事项\"\u003e已完成事项\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003eGo 语言学习\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e完成了 \u003ccode\u003eTour of Go\u003c/code\u003e 的大部分练习。\u003c/li\u003e\n\u003cli\u003e但是也跳过了一些练习，\u003ccode\u003eimage\u003c/code\u003e 接口等内容目前不急需；\u003ccode\u003e二叉查找树\u003c/code\u003e 等概念需要继续沉淀。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eGo by Example 推进\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e已学习到 \u003ccode\u003egoroutine\u003c/code\u003e 的 \u003ccode\u003erate-limiting\u003c/code\u003e 部分。\u003c/li\u003e\n\u003cli\u003e重点学习了\u003ccode\u003e闭包\u003c/code\u003e和\u003ccode\u003egoroutine\u003c/code\u003e及其\u003ccode\u003etimer\u003c/code\u003e、\u003ccode\u003etickers\u003c/code\u003e、\u003ccode\u003ewaitgroup\u003c/code\u003e 等内容。\u003c/li\u003e\n\u003cli\u003e但是也跳过了 \u003ccode\u003e范型\u003c/code\u003e、\u003ccode\u003e枚举\u003c/code\u003e、\u003ccode\u003e迭代器的 range\u003c/code\u003e 等目前不会的内容。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e项目开发 - 智能笔记\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e开始完成智能笔记项目，准备一边学一边开发。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e迈出第一步\u003c/strong\u003e：成功让 API 服务运行起来。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eGin 框架学习\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e初步开始Gin的学习，掌握了 \u003ccode\u003eHTTP 方法\u003c/code\u003e、\u003ccode\u003e路由\u003c/code\u003e、\u003ccode\u003e路由参数\u003c/code\u003e、\u003ccode\u003eJSON\u003c/code\u003e、\u003ccode\u003eQuery\u003c/code\u003e 和 \u003ccode\u003ePost Form\u003c/code\u003e 的使用。\u003c/li\u003e\n\u003cli\u003e计划在后续开发 \u003ccode\u003eJWT\u003c/code\u003e、\u003ccode\u003e日志\u003c/code\u003e 等功能时进行更深入的学习。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e工具与环境\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e安装了 \u003ccode\u003ePostman\u003c/code\u003e、\u003ccode\u003eMySQL\u003c/code\u003e 等开发工具。\u003c/li\u003e\n\u003cli\u003e成功申请了 \u003ccode\u003eGitHub 教育福利\u003c/code\u003e（费了我好大劲，在使用 VPN 的情况下）。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003chr\u003e\n\u003ch2 id=\"下周计划\"\u003e下周计划\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e项目开发继续\u003c/strong\u003e✅\n\u003cul\u003e\n\u003cli\u003e学习 \u003ccode\u003eSQL\u003c/code\u003e 基础语法。\u003c/li\u003e\n\u003cli\u003e初步学习 \u003ccode\u003eGorm\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003e实现笔记的完整 \u003cstrong\u003eCRUD\u003c/strong\u003e 功能。\u003c/li\u003e\n\u003cli\u003e实现数据持久化，接入 \u003ccode\u003eMySQL\u003c/code\u003e 数据库。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e学校课业（可能）\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e可能\u003c/strong\u003e需要回顾学校知识，为 \u003cstrong\u003e10 月中下旬\u003c/strong\u003e 的期中考做准备。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e","title":"第三周总结"},{"content":"woc,这个gin的文档怎么这么傻逼啊，它的example的例子竟然是tm安照首字母排序的！我真的🙃蚌不住了，真的好笑，我🤡tm看了A开头的AsciiJSON半天，没搞懂gin的基础和它有什么关系。我还看了下面有什么自定义HTTP配置，日志文件什么的，我以为是我没怎么学net/http包的问题。屮，谁知道我前面几个都看不懂的无助感，真以为要被技术文档阻挡下来了，要中道崩殂了。\n幸好😅我问了ai，发现基础的是在后面的使用HTTP方法。复活了😑，耶🫠\u0026hellip;\n点\u0026mdash;\u0026gt;🤡\u0026lt;\u0026mdash;击\n好吧，其实我后面看了一下，它似乎是在quick start这里是正常的，按知识难度从基础到困难排的，不过它的注释是英文的，谷歌翻译翻译不到他，所以 一样\n","permalink":"https://sheep44044.github.io/daily/2025-09-26-daily2/","summary":"\u003cp\u003ewoc,这个gin的文档怎么这么傻逼啊，它的example的例子竟然是tm安照首字母排序的！我真的🙃蚌不住了，真的好笑，我🤡tm看了A开头的AsciiJSON半天，没搞懂gin的基础和它有什么关系。我还看了下面有什么自定义HTTP配置，日志文件什么的，我以为是我没怎么学net/http包的问题。屮，谁知道我前面几个都看不懂的无助感，真以为要被技术文档阻挡下来了，要中道崩殂了。\u003c/p\u003e\n\u003cp\u003e幸好😅我问了ai，发现基础的是在后面的使用HTTP方法。复活了😑，耶🫠\u0026hellip;\u003c/p\u003e\n\u003cp\u003e点\u0026mdash;\u0026gt;\u003ca href=\"https://gin-gonic.com/zh-cn/docs/\"\u003e🤡\u003c/a\u003e\u0026lt;\u0026mdash;击\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e好吧，其实我后面看了一下，它似乎是在quick start这里是正常的，按知识难度从基础到困难排的，不过它的注释是英文的，谷歌翻译翻译不到他，所以 一样\u003c/p\u003e","title":"fuck gin"},{"content":"woc，这个string 和 rune怎么这么麻烦😡，我有点看不懂了，以后再看吧👀\n现在先标记一下吧，以后看看(不过go的博客确实不赖，不过我现在太菜了，看不懂)\ngobyexample的字符串\nGo 中的字符串、字节、符文和字符\n","permalink":"https://sheep44044.github.io/daily/2025-09-23-daily1/","summary":"\u003cp\u003ewoc，这个string 和 rune怎么这么麻烦😡，我有点看不懂了，以后再看吧👀\u003c/p\u003e\n\u003cp\u003e现在先标记一下吧，以后看看(不过go的博客确实不赖，不过我现在太菜了，看不懂)\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://gobyexample.com/strings-and-runes\"\u003egobyexample的字符串\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://go.dev/blog/strings\"\u003eGo 中的字符串、字节、符文和字符\u003c/a\u003e\u003c/p\u003e","title":"巴拉巴拉"},{"content":"第二周总结 完成事项 解决了上周博客留下来的问题，有了一个简陋但功能完备的网站 🥳。 在 Tour of Go 上基本完成了所有内容的学习，包括切片、接口、并发等知识点。 持续推进 Go by Example 的学习，目前完成 switch 部分，进入数组相关内容（不得不说gobyexample确实不赖，对于这些基础知识我也能学到新的特性）。 做了一些学习笔记。 下周计划 巩固已学知识，搞懂 Tour of Go 中的练习题。✅ 继续学习 Go by Example 的后续内容。✅ （可能）了解一些常用标准库包的基本用法。 ","permalink":"https://sheep44044.github.io/weekly/2025-09-22-weekly2/","summary":"\u003ch1 id=\"第二周总结\"\u003e第二周总结\u003c/h1\u003e\n\u003ch2 id=\"完成事项\"\u003e完成事项\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e解决了上周博客留下来的问题，有了一个简陋但功能完备的网站 🥳。\u003c/li\u003e\n\u003cli\u003e在 \u003ca href=\"https://tour.go-zh.org/\"\u003eTour of Go\u003c/a\u003e 上基本完成了所有内容的学习，包括切片、接口、并发等知识点。\u003c/li\u003e\n\u003cli\u003e持续推进 \u003ca href=\"https://gobyexample.com/\"\u003eGo by Example\u003c/a\u003e 的学习，目前完成 \u003ccode\u003eswitch\u003c/code\u003e 部分，进入数组相关内容（不得不说gobyexample确实不赖，对于这些基础知识我也能学到新的特性）。\u003c/li\u003e\n\u003cli\u003e做了一些学习笔记。\u003c/li\u003e\n\u003c/ol\u003e\n\u003chr\u003e\n\u003ch2 id=\"下周计划\"\u003e下周计划\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e巩固已学知识，搞懂 Tour of Go 中的练习题。✅\u003c/li\u003e\n\u003cli\u003e继续学习 Go by Example 的后续内容。✅\u003c/li\u003e\n\u003cli\u003e（可能）了解一些常用标准库包的基本用法。\u003c/li\u003e\n\u003c/ol\u003e","title":"第二周总结"},{"content":"Golang之接口 接口是我在tour of go上遇到的第一个难点，因此我打算再开一篇来着重记录，不仅是当下对此的沉淀与思考，也是对未来的提醒与照应。为了方便自己的查看，便独立于之前的知识碎片。\n接口（interface） 接口的定义 接口（Interface）本质上就是定义了一组方法签名（Method Signatures）的集合。它只关心**“做什么”，而不关心“怎么做”**。\n它规定：“任何类型，只要你实现了我的合同里规定的所有这些方法，那我就认为你实现了这个接口。”\n每个接口类型由任意个方法签名组成，接口的定义格式如下：\ntype 接口类型名 interface{ 方法名1( 参数列表1 ) 返回值列表1 方法名2( 参数列表2 ) 返回值列表2 … } 如何实现接口？（“隐式实现”） Go 接口的实现是 “隐式” 的。这意味着你不需要像 Java 那样明确地写 implements Speaker。只需要让这个类型拥有接口里规定的所有方法，它就自动实现了该接口！\n这是 Go 的哲学——“鸭子类型”（如果它走起来像鸭子，叫起来像鸭子，那它就是鸭子）。\n接口值 接口也是值。它们可以像其它值一样传递。\n接口值可以用作函数的参数或返回值。\n接口值可以看作两部分具体类型和该类型的值。\n可以把接口值想象成一个特殊的“盒子”。\n这个盒子上贴着一个标签，写着里面装的东西的类型（*main.Dog）。 盒子里装着实际的值（一个 Dog 结构体的实例）。 var s Speaker // 接口变量 s，此时它是一个空的“盒子”，里面是 nil s = Dog{Name: \u0026#34;Rex\u0026#34;} // 赋值后，s 这个“盒子”里： // - 标签：main.Dog // - 值：{Rex} fmt.Printf(\u0026#34;(%v, %T)\\n\u0026#34;, s, s) // 输出：({Rex}, main.Dog) // 值部分 和 类型部分 当你调用 s.Speak() 时，Go 会打开这个“盒子”，根据标签找到类型 Dog，然后执行 Dog 的 Speak 方法。\n底层值为 nil 的接口值 即便接口内的具体值为 nil，方法仍然会被 nil 接收者调用。保存了 nil 具体值的接口其自身并不为 nil。\nnil 接口值 nil 接口值既不保存值也不保存具体类型。\n为 nil 接口调用方法会产生运行时错误，因为接口的元组内并未包含能够指明该调用哪个 具体 方法的类型。\n空接口（interface{}/any） 空接口可保存任何类型的值（因为每个类型都至少实现了零个方法）\n空接口被用来处理未知类型的值\ntips：\n空接口是一个接口类型。因为它没有规定任何方法，所以Go语言规定所有类型都自动实现了空接口。\nnil接口值指的是一个接口变量的当前状态是“空”的。\n它们之间的关系是正交的：你可以有一个空接口类型的nil接口值，也可以有一个非空的自定义接口类型的nil接口值。\n类型断言 由于接口变量可以持有任意实现它的类型的值，有时我们需要知道它背后具体的实际值是什么。\n在 Go 语言中，接口断言是一种检查接口变量是否具有特定具体类型的方法。接口断言的基本语法如下：\nvalue, ok := interfaceVariable.(Type) 其中：\ninterfaceVariable 是一个接口类型的变量 Type 是你想要断言的具体类型 如果 interfaceVariable 实际上是一个 Type 类型的值，那么 value 将会被赋值为该值，并且 ok 将会是 true。如果 interfaceVariable 不是 Type 类型，那么 value 将会是 Type 类型的零值，而 ok 将会是 false 对于空接口 interface{}，任何类型的值都可以被赋值给它，因此对接口断言的需求更加常见 类型选择 类型选择 是一种按顺序从几个类型断言中选择分支的结构。\n类型选择与一般的 switch 语句相似，不过类型选择中的 case 为类型（而非值）， 它们针对给定接口值所存储的值的类型进行比较。\nswitch v := i.(type) { case T: // v 的类型为 T case S: // v 的类型为 S default: // 没有匹配，v 与 i 的类型相同 } 类型选择中的声明与类型断言 i.(T) 的语法相同，只是具体类型 T 被替换成了关键字 type。\n多态实现 接口变量可以持有任意实现它的类型的值\n多态（Polymorphism） 指的是一个接口的调用方式，可以在运行时根据其底层实际类型的不同而表现出不同的行为\n核心思想： 不同结构体只要实现了相同的接口，它们就可以被当作同一种类型（接口类型）来处理，但在执行接口方法时，会执行各自具体的实现。\n经典例子：\npackage main import \u0026#34;fmt\u0026#34; // 定义一个支付接口 type Payment interface { Pay(amount float64) string } // 实现两种不同的支付方式 type Alipay struct { Account string } func (a Alipay) Pay(amount float64) string { return fmt.Sprintf(\u0026#34;使用支付宝 %s 支付了 %.2f 元\u0026#34;, a.Account, amount) } type WechatPay struct { OpenID string } func (w WechatPay) Pay(amount float64) string { return fmt.Sprintf(\u0026#34;使用微信 %s 支付了 %.2f 元\u0026#34;, w.OpenID, amount) } // 一个通用的支付函数，它只关心传入的对象是否实现了 Payment 接口 func ProcessPayment(p Payment, amount float64) { result := p.Pay(amount) fmt.Println(result) } func main() { a := Alipay{Account: \u0026#34;zhangsan@alipay.com\u0026#34;} w := WechatPay{OpenID: \u0026#34;wx_abcdef123456\u0026#34;} // 多态的体现：ProcessPayment 函数不需要知道具体是哪种支付方式 // 它只需要调用 Pay 方法，而具体执行哪个版本的 Pay，由运行时 p 的实际类型决定 ProcessPayment(a, 100.5) ProcessPayment(w, 200.0) // 也可以将不同的实现放入同一个切片（接口类型切片） payments := []Payment{a, w} for _, payer := range payments { ProcessPayment(payer, 50.0) } } 输出：\n使用支付宝 zhangsan@alipay.com 支付了 100.50 元 使用微信 wx_abcdef123456 支付了 200.00 元 使用支付宝 zhangsan@alipay.com 支付了 50.00 元 使用微信 wx_abcdef123456 支付了 50.00 元 Go的\u0026quot;继承\u0026quot; Go 语言设计者认为传统的类继承（尤其是多重继承）模型复杂且容易出错。因此，Go 彻底摒弃了 class 和 extends 的概念。\nGo 的“继承”是通过结构体的嵌套（Embedding）来实现的，这本质上是“组合”。\n// “父类”（基类） type Animal struct { name string } func (a *Animal) Speak() { fmt.Println(\u0026#34;我是:\u0026#34;, a.name) } // “子类”（派生类），通过嵌入 Animal 来“继承”它的字段和方法 type Dog struct { Animal // 嵌入 Animal，实现了组合 Breed string // 子类自己的字段 } // 子类可以重写父类的方法 func (d *Dog) Speak() { d.Animal.Speak() // 可以调用“父类”的方法 fmt.Println(\u0026#34;汪汪汪！\u0026#34;) } func main() { d := Dog{ Animal: Animal{name: \u0026#34;旺财\u0026#34;}, // 初始化嵌入的结构体 Breed: \u0026#34;柯基\u0026#34;, } d.Speak() // 调用子类重写后的方法 d.Animal.Speak() // 仍然可以显式调用父类的方法 } 这种组合的优势：\n清晰简单：没有复杂的继承链。 解耦：Dog 和 Animal 是两个独立的类型，Dog 只是使用了 Animal 的功能。 灵活性：Dog 可以轻松组合多个其他结构体（例如 Pet）的功能，模拟了“多重继承”，但又没有多重继承的歧义问题。 常见的接口 1.Stringer fmt 包中定义的 Stringer 是最普遍的接口之一。\ntype Stringer interface { String() string } Stringer 是一个可以用字符串描述自己的类型。fmt 包（还有很多包）都通过此接口来打印值。\n2.error Go 程序使用 error 值来表示错误状态。\n与 fmt.Stringer 类似，error 类型是一个内建接口：\ntype error interface { Error() string } （与 fmt.Stringer 类似，fmt 包也会根据对 error 的实现来打印值。）\n通常函数会返回一个 error 值，调用它的代码应当判断这个错误是否等于 nil 来进行错误处理。\ni, err := strconv.Atoi(\u0026#34;42\u0026#34;) if err != nil { fmt.Printf(\u0026#34;couldn\u0026#39;t convert number: %v\\n\u0026#34;, err) return } fmt.Println(\u0026#34;Converted integer:\u0026#34;, i) error 为 nil 时表示成功；非 nil 的 error 表示失败。\n3.Readers io 包指定了 io.Reader 接口，它表示数据流的读取端。\nGo 标准库包含了该接口的许多实现，包括文件、网络连接、压缩和加密等等。\nio.Reader 接口有一个 Read 方法：\nfunc (T) Read(b []byte) (n int, err error) Read 用数据填充给定的字节切片并返回填充的字节数和错误值。在遇到数据流的结尾时，它会返回一个 io.EOF 错误。\n4.Image image 包定义了 Image 接口：\npackage image type Image interface { ColorModel() color.Model Bounds() Rectangle At(x, y int) color.Color } 注意: Bounds 方法的返回值 Rectangle 实际上是一个 image.Rectangle，它在 image 包中声明。\n","permalink":"https://sheep44044.github.io/posts/2025-09-19-interface/","summary":"\u003ch1 id=\"golang之接口\"\u003eGolang之接口\u003c/h1\u003e\n\u003cp\u003e接口是我在tour of go上遇到的第一个难点，因此我打算再开一篇来着重记录，不仅是当下对此的沉淀与思考，也是对未来的提醒与照应。为了方便自己的查看，便独立于之前的知识碎片。\u003c/p\u003e\n\u003ch2 id=\"接口interface\"\u003e接口（interface）\u003c/h2\u003e\n\u003ch3 id=\"接口的定义\"\u003e接口的定义\u003c/h3\u003e\n\u003cp\u003e接口（Interface）本质上就是\u003cstrong\u003e定义了一组方法签名（Method Signatures）的集合\u003c/strong\u003e。它只关心**“做什么”\u003cstrong\u003e，而不关心\u003c/strong\u003e“怎么做”**。\u003c/p\u003e\n\u003cp\u003e它规定：\u003cstrong\u003e“任何类型，只要你实现了我的合同里规定的所有这些方法，那我就认为你实现了这个接口。”\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e每个接口类型由任意个方法签名组成，接口的定义格式如下：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-go\" data-lang=\"go\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etype\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003e接口类型名\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003einterface\u003c/span\u003e{\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003e方法名1\u003c/span\u003e( \u003cspan style=\"color:#a6e22e\"\u003e参数列表1\u003c/span\u003e ) \u003cspan style=\"color:#a6e22e\"\u003e返回值列表1\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003e方法名2\u003c/span\u003e( \u003cspan style=\"color:#a6e22e\"\u003e参数列表2\u003c/span\u003e ) \u003cspan style=\"color:#a6e22e\"\u003e返回值列表2\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e…\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"如何实现接口隐式实现\"\u003e如何实现接口？（“隐式实现”）\u003c/h3\u003e\n\u003cp\u003eGo 接口的实现是 \u003cstrong\u003e“隐式”\u003c/strong\u003e 的。这意味着你\u003cstrong\u003e不需要\u003c/strong\u003e像 Java 那样明确地写 \u003ccode\u003eimplements Speaker\u003c/code\u003e。只需要让这个类型拥有接口里规定的所有方法，它就自动实现了该接口！\u003c/p\u003e\n\u003cp\u003e这是 Go 的哲学——“鸭子类型”（如果它走起来像鸭子，叫起来像鸭子，那它就是鸭子）。\u003c/p\u003e\n\u003ch2 id=\"接口值\"\u003e接口值\u003c/h2\u003e\n\u003cp\u003e接口也是值。它们可以像其它值一样传递。\u003c/p\u003e\n\u003cp\u003e接口值可以用作函数的参数或返回值。\u003c/p\u003e\n\u003cp\u003e接口值可以看作两部分\u003cstrong\u003e具体类型\u003c/strong\u003e和\u003cstrong\u003e该类型的值\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e可以把接口值想象成一个特殊的“盒子”。\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e这个盒子上贴着一个\u003cstrong\u003e标签\u003c/strong\u003e，写着里面装的东西的类型（\u003ccode\u003e*main.Dog\u003c/code\u003e）。\u003c/li\u003e\n\u003cli\u003e盒子里装着\u003cstrong\u003e实际的值\u003c/strong\u003e（一个 \u003ccode\u003eDog\u003c/code\u003e 结构体的实例）。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-go\" data-lang=\"go\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003evar\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003es\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eSpeaker\u003c/span\u003e      \u003cspan style=\"color:#75715e\"\u003e// 接口变量 s，此时它是一个空的“盒子”，里面是 nil\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003es\u003c/span\u003e = \u003cspan style=\"color:#a6e22e\"\u003eDog\u003c/span\u003e{\u003cspan style=\"color:#a6e22e\"\u003eName\u003c/span\u003e: \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;Rex\u0026#34;\u003c/span\u003e} \u003cspan style=\"color:#75715e\"\u003e// 赋值后，s 这个“盒子”里：\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                     \u003cspan style=\"color:#75715e\"\u003e// - 标签：main.Dog\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                     \u003cspan style=\"color:#75715e\"\u003e// - 值：{Rex}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003efmt\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003ePrintf\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;(%v, %T)\\n\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003es\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003es\u003c/span\u003e) \u003cspan style=\"color:#75715e\"\u003e// 输出：({Rex}, main.Dog)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                               \u003cspan style=\"color:#75715e\"\u003e// 值部分 和 类型部分\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e当你调用 \u003ccode\u003es.Speak()\u003c/code\u003e 时，Go 会打开这个“盒子”，根据标签找到类型 \u003ccode\u003eDog\u003c/code\u003e，然后执行 \u003ccode\u003eDog\u003c/code\u003e 的 \u003ccode\u003eSpeak\u003c/code\u003e 方法。\u003c/p\u003e","title":"Golang之接口"},{"content":"Golang的知识碎片 在此之前golang单纯看蓝山的文档，感觉学的很浅很零碎，所以打算重新看一遍。因为go by example、tour go和蓝山工作室的文档比较完善，所以下方将着重提及一些之前不太清楚的零碎知识，提醒自己。\n0.Go 语言的零值机制\n在 Go 语言中，所有变量在声明时都会被自动初始化为其类型的零值（zero value）：\n数值类型：0 布尔类型：false 字符串类型：\u0026quot;\u0026quot;（空字符串） 指针、接口、切片、映射、通道：nil 结构体：每个字段都初始化为其类型的零值 1.变量声明\n关于变量的声明包括两部分，类型和初始值，变量会从初始值中推断出类型或从类型中推断出初始值（即零值）\n2.返回值\nGo 的返回值可以被命名（向前面的参数一样），return后面没有参数，就会返回没有命名的返回值\n3.条件语句前简短语句\nfor和if 语句可以在条件表达式前执行一个简短语句\n4.无条件的switch(类似于if-else)\nswitch { case x \u0026lt; 0: fmt.Println(\u0026#34;Negative\u0026#34;) case x == 0: fmt.Println(\u0026#34;Zero\u0026#34;) default: fmt.Println(\u0026#34;Positive\u0026#34;) } 5.defer推迟/defer栈\ndefer 语句会将函数调用推迟到外层函数返回之后执行 被推迟的函数调用会被压入一个栈中，当外层函数返回时，被推迟的函数会按照后进先出（LIFO）的顺序执行 6.函数闭包\n闭包 = 函数 + 外部变量变量\n状态保持：闭包可以记住并修改外部变量 独立实例：每次调用外部函数都会创建新的闭包实例 实用性强：用于需要保持状态的场景 如何判断外部变量\n\u0026ldquo;这个变量是在内层函数内部定义的，还是外部定义的？\u0026rdquo; 再问：\u0026ldquo;内层函数是否使用了这个外部变量？\u0026rdquo; 如果两个答案都是\u0026quot;是\u0026quot;：那么这个变量就是被捕获的外部变量 7.方法\n方法可以看作有接收者的函数，不过带指针/值参数的函数必须接受一个指针/值，不然会报错，而以指针/值为接收者的方法被调用时，接收者既能为值又能为指针，不过能不能生效另说\n8.接收者类型\n接收者有两种类型，值接收者和指针接收者。\n使用指针接收者的两个原因：\n1.方法需要修改接收者的值，值接收者只能改变副本，指针可以改变原始值\n2.提高效率，每次方法调用时，Go 需要将整个结构体的数据复制一份给方法使用。如果结构体非常大，这个复制操作的开销会很大。而Go 只需要复制一个指针（通常是一个机器字长的大小，如 8 字节），开销极小。\n所以，大部分的时候使用指针\ntips\n对于一个特定的类型，你应该决定是使用值接收者还是指针接收者，并为该类型的所有方法保持一致。\n9.值类型/引用类型\n这是 Go 语言中一个非常重要的概念，决定了变量如何被分配内存、如何被赋值以及如何被传递给函数。\n值类型 (Value Types) 包括： 所有基本数据类型（如 int, float64, bool, string）、数组（Array）、结构体（struct）。 行为特点： 变量直接存储值本身。 赋值操作和函数传参时，会创建值的完整副本。 修改副本不会影响原始值。 在内存中，通常被分配在栈（Stack） 上（但编译器也可能决定分配在堆上）。 // 值类型示例：数组 arr1 := [3]int{1, 2, 3} arr2 := arr1 // 将 arr1 的【所有值】完整地复制一份给 arr2 arr2[0] = 100 // 修改副本 fmt.Println(arr1) // 输出: [1 2 3] (原值未改变) fmt.Println(arr2) // 输出: [100 2 3] 引用类型 (Reference Types) 包括： 切片（Slice）、映射（Map）、通道（Channel）、指针（Pointer）、函数（Function）。 行为特点： 变量存储的是一个“引用”（可以理解为内存地址），这个引用指向底层真正存储数据的内存空间。 赋值操作和函数传参时，复制的是这个“引用”（内存地址），而不是底层数据本身。 多个变量可以共享同一份底层数据。通过任何一个变量修改底层数据，其他所有引用它的变量都会“看到”这个变化。 底层数据通常存储在堆（Heap） 上。 // 引用类型示例：切片 slice1 := []int{1, 2, 3} slice2 := slice1 // 复制的是引用（地址），现在 slice1 和 slice2 指向同一个底层数组 slice2[0] = 100 // 通过 slice2 修改底层数组 fmt.Println(slice1) // 输出: [100 2 3] (原值被改变了！) fmt.Println(slice2) // 输出: [100 2 3] 总结对比表 特性 值类型 引用类型 代表类型 int, array, struct, string slice, map, channel, pointer 变量存储内容 实际的数据值 指向底层数据的地址（引用） 赋值/传参行为 复制整个数据值，创建独立副本 复制引用地址，共享底层数据 修改副本的影响 不影响原始数据 影响原始数据 内存主要位置 栈 堆（数据本身），变量本身可能在栈 10.匿名函数/结构体\u0026hellip;\n暂时不太懂，标记一下\n","permalink":"https://sheep44044.github.io/posts/first-post/","summary":"\u003ch1 id=\"golang的知识碎片\"\u003eGolang的知识碎片\u003c/h1\u003e\n\u003cp\u003e在此之前golang单纯看蓝山的文档，感觉学的很浅很零碎，所以打算重新看一遍。因为go by example、tour go和蓝山工作室的文档比较完善，所以下方将着重提及一些之前不太清楚的零碎知识，提醒自己。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e0.Go 语言的零值机制\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e在 Go 语言中，所有变量在声明时都会被自动初始化为其类型的\u003cstrong\u003e零值\u003c/strong\u003e（zero value）：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e数值类型：\u003ccode\u003e0\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e布尔类型：\u003ccode\u003efalse\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e字符串类型：\u003ccode\u003e\u0026quot;\u0026quot;\u003c/code\u003e（空字符串）\u003c/li\u003e\n\u003cli\u003e指针、接口、切片、映射、通道：\u003ccode\u003enil\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e结构体：每个字段都初始化为其类型的零值\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e1.变量声明\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e关于变量的声明包括两部分，类型和初始值，变量会从初始值中推断出类型或从类型中推断出初始值（即零值）\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e2.返回值\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eGo 的返回值可以被命名（向前面的参数一样），return后面没有参数，就会返回没有命名的返回值\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e3.条件语句前简短语句\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003efor和\u003ccode\u003eif\u003c/code\u003e 语句可以在条件表达式前执行一个简短语句\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e4.无条件的switch(类似于if-else)\u003c/strong\u003e\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-go\" data-lang=\"go\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eswitch\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003ecase\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ex\u003c/span\u003e \u0026lt; \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003efmt\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003ePrintln\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;Negative\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003ecase\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ex\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003efmt\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003ePrintln\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;Zero\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003edefault\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003efmt\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003ePrintln\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;Positive\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\u003cstrong\u003e5.defer推迟/defer栈\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003edefer\u003c/code\u003e 语句会将函数调用推迟到外层函数返回之后执行\u003c/li\u003e\n\u003cli\u003e被推迟的函数调用会被压入一个\u003cstrong\u003e栈\u003c/strong\u003e中，当外层函数返回时，被推迟的函数会按照\u003cstrong\u003e后进先出\u003c/strong\u003e（LIFO）的顺序执行\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e6.函数闭包\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e闭包 = 函数 + 外部变量变量\u003c/strong\u003e\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e状态保持\u003c/strong\u003e：闭包可以记住并修改外部变量\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e独立实例\u003c/strong\u003e：每次调用外部函数都会创建新的闭包实例\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e实用性强\u003c/strong\u003e：用于需要保持状态的场景\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e如何判断外部变量\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u0026ldquo;这个变量是在内层函数内部定义的，还是外部定义的？\u0026rdquo;\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e再问\u003c/strong\u003e：\u0026ldquo;内层函数是否使用了这个外部变量？\u0026rdquo;\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e如果两个答案都是\u0026quot;是\u0026quot;\u003c/strong\u003e：那么这个变量就是被捕获的外部变量\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cstrong\u003e7.方法\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e方法可以看作有接收者的函数，不过带指针/值参数的函数必须接受一个指针/值，不然会报错，而以指针/值为接收者的方法被调用时，接收者既能为值又能为指针，不过能不能生效另说\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e8.接收者类型\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e接收者有两种类型，\u003cstrong\u003e值接收者\u003c/strong\u003e和\u003cstrong\u003e指针接收者\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e使用指针接收者的两个原因：\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e1.方法需要修改接收者的值，值接收者只能改变副本，指针可以改变原始值\u003c/p\u003e\n\u003cp\u003e2.提高效率，每次方法调用时，Go 需要将整个结构体的数据\u003cstrong\u003e复制\u003c/strong\u003e一份给方法使用。如果结构体非常大，这个复制操作的开销会很大。而Go 只需要复制一个\u003cstrong\u003e指针\u003c/strong\u003e（通常是一个机器字长的大小，如 8 字节），开销极小。\u003c/p\u003e\n\u003cp\u003e所以，大部分的时候使用指针\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003etips\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e对于一个特定的类型，你应该决定是使用值接收者还是指针接收者，并\u003cstrong\u003e为该类型的所有方法保持一致\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e9.值类型/引用类型\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e这是 Go 语言中一个非常重要的概念，决定了变量如何被分配内存、如何被赋值以及如何被传递给函数。\u003c/p\u003e","title":"Golang的知识碎片（基础篇）"},{"content":"第一周总结 本周主要完成了以下三件事情：\n完成事项 熟悉 Mac 并配置软件环境\n开始熟悉 macOS 操作系统。 使用 Jetbrans Toolbox 安装 Goland 等开发工具。 通过 Homebrew 包管理器安装并管理 Git、Typora 等软件。 学习并使用 Git\n通过教程网站 learngitbranching.js.org 的git小游戏来学习和练习 Git 操作。 成功配置 Git 并与我的 GitHub 账户进行关联。 实现了在 Goland IDE 中集成并使用 Git。 利用 Hugo 搭建博客\n使用 Hugo 静态网站生成器初步搭建了个人博客。 实现了基本功能：主页文章展示、包含“文章”和“周报”等菜单的导航栏。 下周计划 ✅ 解决博客的一个小问题：博客在互联网上登入时会错误跳转到本地。 复习 Golang 的知识。 ","permalink":"https://sheep44044.github.io/weekly/weekly-1/","summary":"\u003ch1 id=\"第一周总结\"\u003e第一周总结\u003c/h1\u003e\n\u003cp\u003e本周主要完成了以下三件事情：\u003c/p\u003e\n\u003ch2 id=\"完成事项\"\u003e完成事项\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e熟悉 Mac 并配置软件环境\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e开始熟悉 macOS 操作系统。\u003c/li\u003e\n\u003cli\u003e使用 Jetbrans Toolbox 安装 Goland 等开发工具。\u003c/li\u003e\n\u003cli\u003e通过 Homebrew 包管理器安装并管理 Git、Typora 等软件。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e学习并使用 Git\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e通过教程网站 \u003ca href=\"https://learngitbranching.js.org/?demo=\u0026amp;locale=zh_CN\"\u003elearngitbranching.js.org\u003c/a\u003e 的git小游戏来学习和练习 Git 操作。\u003c/li\u003e\n\u003cli\u003e成功配置 Git 并与我的 GitHub 账户进行关联。\u003c/li\u003e\n\u003cli\u003e实现了在 Goland IDE 中集成并使用 Git。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e利用 Hugo 搭建博客\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e使用 \u003ccode\u003eHugo\u003c/code\u003e 静态网站生成器初步搭建了个人博客。\u003c/li\u003e\n\u003cli\u003e实现了基本功能：主页文章展示、包含“文章”和“周报”等菜单的导航栏。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003chr\u003e\n\u003ch2 id=\"下周计划-\"\u003e下周计划 ✅\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e解决博客的一个小问题：博客在互联网上登入时会错误跳转到本地。\u003c/li\u003e\n\u003cli\u003e复习 Golang 的知识。\u003c/li\u003e\n\u003c/ul\u003e","title":"第一周总结"},{"content":"关于我 🥳\n我是 sheep44044，一名CQUPT的24级学生🧑‍🎓，一名对世界充满好奇的探索者。\n🚀 我正在学习：Git, Golang 以及其他有趣的开发技术。 📝 我正在记录：学习过程中的思考、总结和牢骚😩。 🎃 我的兴趣：代码、游戏、发呆ing。 🎯 展望\n提升自己 留点时间给自己 探索些感兴趣的东西 这个博客是我成长路上的数字脚印，也是你眼前看到的第一个小成果！旨在记录和分享我的学习历程与偶尔的碎碎念。如果这里的内容能给你带来一丝启发或帮助，那将是我最大的荣幸。\n💌 联系我：3290120053@qq.com\n🐙 GitHub: sheep44044\n感谢你的到访！期待与你交流。祝你今天过得愉快！✨\n","permalink":"https://sheep44044.github.io/about/","summary":"\u003cp\u003e关于我 🥳\u003c/p\u003e\n\u003cp\u003e我是 \u003cstrong\u003esheep44044\u003c/strong\u003e，一名CQUPT的24级学生🧑‍🎓，一名对世界充满好奇的探索者。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e🚀 \u003cstrong\u003e我正在学习\u003c/strong\u003e：Git, Golang 以及其他有趣的开发技术。\u003c/li\u003e\n\u003cli\u003e📝 \u003cstrong\u003e我正在记录\u003c/strong\u003e：学习过程中的思考、总结和牢骚😩。\u003c/li\u003e\n\u003cli\u003e🎃 \u003cstrong\u003e我的兴趣\u003c/strong\u003e：代码、游戏、发呆ing。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e🎯 展望\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e提升自己\u003c/li\u003e\n\u003cli\u003e留点时间给自己\u003c/li\u003e\n\u003cli\u003e探索些感兴趣的东西\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e这个博客是我成长路上的数字脚印，也是你眼前看到的第一个小成果！旨在记录和分享我的学习历程与偶尔的碎碎念。如果这里的内容能给你带来一丝启发或帮助，那将是我最大的荣幸。\u003c/p\u003e\n\u003cp\u003e💌 \u003cstrong\u003e联系我\u003c/strong\u003e：\u003ccode\u003e3290120053@qq.com\u003c/code\u003e\u003cbr\u003e\n🐙 \u003cstrong\u003eGitHub\u003c/strong\u003e: \u003ca href=\"https://github.com/sheep44044\"\u003esheep44044\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e感谢你的到访！期待与你交流。祝你今天过得愉快！✨\u003c/p\u003e","title":"关于我"},{"content":"种一棵树最好的时间是十年前，其次是现在。 大一的时候，我初出茅庐，渴望着完美，绩点、开发、算法一并取得，最后什么都没拿到。\n现在，希望专注于一点，取得一丝成就吧。\n— 2025.9.13\n只有选择，没有对错，喜欢的事，勇敢去做，不要怕，不喜欢的事，尽力而为，听从自己内心的选择。\n在网上，人们说大学最好的时光是在高中时，最好的高中时光在大学生活中。回顾高中三年，我却难以会想起我自身的成就和生活的美好，就连学习也没有学到什么——周末、寒暑去补课，最终，却还是需要父母的帮助才来到重邮。\n悟以往之不谏，知来者之可追。我希望能通过日记来记录自己的学习，亦是提醒自己不要忘记过去的遗憾和那每年的30000元学费。\n我希望能通过自己的蜕变，逐渐成长，达成以下目标：\n拿到奖学金 通过红岩和蓝山的考核 进入ACM集训队 拿到地区的奖牌 获得浙大的录取通知书或是大厂的offer 虽然我的目标实现十分困难，也没有任何实现的依据。但是，我希望借此来激发自己，成为别人口中聪明的孩子，对得起父母、自己和每年的30000元。\n这些想法积聚我脑中已久，借此，我想放空我的脑袋，把这些情绪与计划一同放于日记中，付诸更多的行动，来更好地学习。至于对象、健身这些对我虚无缥缈的东西，尽力而为吧。\nFIGHTing — 2024.11.8\n","permalink":"https://sheep44044.github.io/daily/my-first-post/","summary":"\u003ch1 id=\"种一棵树最好的时间是十年前其次是现在\"\u003e种一棵树最好的时间是十年前，其次是现在。\u003c/h1\u003e\n\u003cp\u003e大一的时候，我初出茅庐，渴望着完美，绩点、开发、算法一并取得，最后什么都没拿到。\u003c/p\u003e\n\u003cp\u003e现在，希望专注于一点，取得一丝成就吧。\u003cbr\u003e\n— 2025.9.13\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e只有选择，没有对错，喜欢的事，勇敢去做，不要怕，不喜欢的事，尽力而为，听从自己内心的选择。\u003c/p\u003e\n\u003cp\u003e在网上，人们说大学最好的时光是在高中时，最好的高中时光在大学生活中。回顾高中三年，我却难以会想起我自身的成就和生活的美好，就连学习也没有学到什么——周末、寒暑去补课，最终，却还是需要父母的帮助才来到重邮。\u003c/p\u003e\n\u003cp\u003e悟以往之不谏，知来者之可追。我希望能通过日记来记录自己的学习，亦是提醒自己不要忘记过去的遗憾和那每年的30000元学费。\u003c/p\u003e\n\u003cp\u003e我希望能通过自己的蜕变，逐渐成长，达成以下目标：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e拿到奖学金\u003c/li\u003e\n\u003cli\u003e通过红岩和蓝山的考核\u003c/li\u003e\n\u003cli\u003e进入ACM集训队\u003c/li\u003e\n\u003cli\u003e拿到地区的奖牌\u003c/li\u003e\n\u003cli\u003e获得浙大的录取通知书或是大厂的offer\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e虽然我的目标实现十分困难，也没有任何实现的依据。但是，我希望借此来激发自己，成为别人口中聪明的孩子，对得起父母、自己和每年的30000元。\u003c/p\u003e\n\u003cp\u003e这些想法积聚我脑中已久，借此，我想放空我的脑袋，把这些情绪与计划一同放于日记中，付诸更多的行动，来更好地学习。至于对象、健身这些对我虚无缥缈的东西，尽力而为吧。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eFIGHTing\u003c/strong\u003e       — 2024.11.8\u003c/p\u003e","title":"My First Post"}]